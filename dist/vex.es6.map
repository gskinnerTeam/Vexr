{"version":3,"names":[],"mappings":"","sources":["vex.es6.js"],"sourcesContent":["class Vector2 {\r\n\r\n\tstatic angleBetween(a, b) {\r\n\t\treturn Math.atan2(b.y - a.y, b.x - a.x);\r\n\t}\r\n\r\n\tstatic lerp(a, b, t) {\r\n\t\tvar x = a.x + t * (b.x - a.x);\r\n\t\tvar y = a.y + t * (b.y - a.y);\r\n\t\treturn new Vector2(x, y);\r\n\t}\r\n\r\n\tstatic map(value, bottomA, topA, bottomB, topB) {\r\n\t\treturn bottomB + (topB - bottomB) * (value - bottomA) / (topA - bottomA);\r\n\t}\r\n\r\n\tstatic normalize(vector) {\r\n\t\tvar vec = vector.get();\r\n\t\treturn vec.normalize();\r\n\t}\r\n\r\n\tstatic radiansToDegrees(radians) {\r\n\t\treturn radians * (180 / Math.PI);\r\n\t}\r\n\r\n\tstatic degreesToRadians(degrees) {\r\n\t\treturn degrees * (Math.PI / 180);\r\n\t}\r\n\r\n\tstatic add(a, b) {\r\n\t\treturn new Vector2((a.x + b.x), (a.y + b.y));\r\n\t}\r\n\r\n\tstatic subtract(a, b) {\r\n\t\tvar n = new Vector2(b.x, b.y);\r\n\t\tn.negate();\r\n\t\treturn Vector2.add(a, n);\r\n\t}\r\n\r\n\tstatic multiply(a, scalar) {\r\n\t\treturn new Vector2(a.x * scalar, a.y * scalar);\r\n\t}\r\n\r\n\tstatic divide(a, scalar) {\r\n\t\tscalar = 1 / scalar;\r\n\t\treturn Vector2.multiply(a, scalar);\r\n\t}\r\n\r\n\tstatic dot(a, b) {\r\n\t\treturn a.x * b.x + a.y * b.y;\r\n\t}\r\n\r\n\tstatic dist(a, b) {\r\n\t\tvar vec1 = a.x - b.x;\r\n\t\tvar vec2 = a.y - b.y;\r\n\t\treturn Math.sqrt((vec1 * vec1) + (vec2 * vec2));\r\n\t}\r\n\r\n\tconstructor(x = 0, y = 0) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tget() {\r\n\t\treturn new Vector2(this.x, this.y);\r\n\t}\r\n\r\n\tset(x, y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tmultiply(scalar) {\r\n\t\tthis.x = this.x * scalar;\r\n\t\tthis.y = this.y * scalar;\r\n\t}\r\n\r\n\tadd(v) {\r\n\t\tthis.x = this.x + v.x;\r\n\t\tthis.y = this.y + v.y;\r\n\t}\r\n\r\n\tsubtract(v) {\r\n\t\tvar n = new Vector2(v.x, v.y);\r\n\t\tn.negate();\r\n\t\tthis.add(n);\r\n\t}\r\n\r\n\tdivide(scalar) {\r\n\t\tscalar = 1 / scalar;\r\n\t\tthis.multiply(scalar);\r\n\t}\r\n\r\n\tnegate() {\r\n\t\tthis.x = -this.x;\r\n\t\tthis.y = -this.y;\r\n\t}\r\n\r\n\tclamp(limit) {\r\n\t\tif (this.x > limit) {\r\n\t\t\tthis.x = limit;\r\n\t\t} else if (this.x < 0 && this.x < limit) {\r\n\t\t\tthis.x = -limit;\r\n\t\t}\r\n\t\tif (this.y > limit) {\r\n\t\t\tthis.y = limit;\r\n\t\t} else if (this.y < 0 && this.y < limit) {\r\n\t\t\tthis.y = -limit;\r\n\t\t}\r\n\t}\r\n\r\n\tlimit(limit) {\r\n\t\tif (this.magnitude() > limit) {\r\n\t\t\tthis.normalize();\r\n\t\t\tthis.multiply(limit);\r\n\t\t}\r\n\t}\r\n\r\n\trotate(degrees, pivotVector = new Vector2(0,0)) {\r\n\t\tvar rads = Vector2.degreesToRadians(degrees);\r\n\t\tvar cosineAngle = Math.cos(rads);\r\n\t\tvar sineAngle = Math.sin(rads);\r\n\t\tthis.x = (cosineAngle * (this.x - pivotVector.x)) + (sineAngle * (this.y - pivotVector.y)) + pivotVector.x;\r\n\t\tthis.y = (cosineAngle * (this.y - pivotVector.y)) - (sineAngle * (this.x - pivotVector.x)) + pivotVector.y;\r\n\t}\r\n\r\n\tmagnitude() {\r\n\t\treturn Math.sqrt(Vector2.dot(this, this));\r\n\t}\r\n\r\n\tnormalize() {\r\n\t\tvar m = this.magnitude();\r\n\t\tif (m > 0) {\r\n\t\t\tthis.divide(m);\r\n\t\t}\r\n\t}\r\n\r\n}\n\n// export Behaviors from \"./Behaviors\";\n\nexport { Vector2 };\n"],"file":"vex.es6.js"}