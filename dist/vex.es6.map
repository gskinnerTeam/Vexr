{"version":3,"names":[],"mappings":"","sources":["vex.es6.js"],"sourcesContent":["class Vector2 {\n\n\tstatic angleBetween(a, b) {\n\t\treturn Math.atan2(b.y - a.y, b.x - a.x);\n\t}\n\n\tstatic lerp(a, b, t) {\n\t\tvar x = a.x + t * (b.x - a.x);\n\t\tvar y = a.y + t * (b.y - a.y);\n\t\treturn new Vector2(x, y);\n\t}\n\n\tstatic map(value, bottomA, topA, bottomB, topB) {\n\t\treturn bottomB + (topB - bottomB) * (value - bottomA) / (topA - bottomA);\n\t}\n\n\tstatic normalize(vector) {\n\t\tvar vec = vector.get();\n\t\treturn vec.normalize();\n\t}\n\n\tstatic radiansToDegrees(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t}\n\n\tstatic degreesToRadians(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t}\n\n\tstatic add(a, b) {\n\t\treturn new Vector2((a.x + b.x), (a.y + b.y));\n\t}\n\n\tstatic subtract(a, b) {\n\t\tvar n = new Vector2(b.x, b.y);\n\t\tn.negate();\n\t\treturn Vector2.add(a, n);\n\t}\n\n\tstatic multiply(a, scalar) {\n\t\treturn new Vector2(a.x * scalar, a.y * scalar);\n\t}\n\n\tstatic divide(a, scalar) {\n\t\tscalar = 1 / scalar;\n\t\treturn Vector2.multiply(a, scalar);\n\t}\n\n\tstatic dot(a, b) {\n\t\treturn a.x * b.x + a.y * b.y;\n\t}\n\n\tstatic dist(a, b) {\n\t\tvar vec1 = a.x - b.x;\n\t\tvar vec2 = a.y - b.y;\n\t\treturn Math.sqrt((vec1 * vec1) + (vec2 * vec2));\n\t}\n\n\tconstructor(x = 0, y = 0) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tget() {\n\t\treturn new Vector2(this.x, this.y);\n\t}\n\n\tset(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tmultiply(scalar) {\n\t\tthis.x = this.x * scalar;\n\t\tthis.y = this.y * scalar;\n\t}\n\n\tadd(v) {\n\t\tthis.x = this.x + v.x;\n\t\tthis.y = this.y + v.y;\n\t}\n\n\tsubtract(v) {\n\t\tvar n = new Vector2(v.x, v.y);\n\t\tn.negate();\n\t\tthis.add(n);\n\t}\n\n\tdivide(scalar) {\n\t\tscalar = 1 / scalar;\n\t\tthis.multiply(scalar);\n\t}\n\n\tnegate() {\n\t\tthis.x = -this.x;\n\t\tthis.y = -this.y;\n\t}\n\n\tclamp(limit) {\n\t\tif (this.x > limit) {\n\t\t\tthis.x = limit;\n\t\t} else if (this.x < 0 && this.x < limit) {\n\t\t\tthis.x = -limit;\n\t\t}\n\t\tif (this.y > limit) {\n\t\t\tthis.y = limit;\n\t\t} else if (this.y < 0 && this.y < limit) {\n\t\t\tthis.y = -limit;\n\t\t}\n\t}\n\n\tlimit(limit) {\n\t\tif (this.magnitude() > limit) {\n\t\t\tthis.normalize();\n\t\t\tthis.multiply(limit);\n\t\t}\n\t}\n\n\trotate(degrees) {\n\t\tvar rads = Vector2.degreesToRadians(degrees);\n\t\tvar cosineAngle = Math.cos(rads);\n\t\tvar sineAngle = Math.sin(rads);\n\t\tthis.x = cosineAngle * this.x - sineAngle * this.y;\n\t\tthis.y = sineAngle * this.x + cosineAngle * this.y;\n\t}\n\n\tmagnitude() {\n\t\treturn Math.sqrt(Vector2.dot(this, this));\n\t}\n\n\tnormalize() {\n\t\tvar m = this.magnitude();\n\t\tif (m > 0) {\n\t\t\tthis.divide(m);\n\t\t}\n\t}\n\n}\n\n// export Behaviors from \"./Behaviors\";\n\nexport { Vector2 };\n"],"file":"vex.es6.js"}