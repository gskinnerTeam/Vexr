{"version":3,"names":[],"mappings":"","sources":["vexr.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n/**\r\n * Small library of converters needed for the various Vexr operations\r\n * @class Convert\r\n */\n\nvar Convert = function () {\n    function Convert() {\n        classCallCheck(this, Convert);\n    }\n\n    createClass(Convert, null, [{\n        key: \"RadiansToDegrees\",\n\n        /**\r\n         * @static RadiansToDegrees() returns degrees you pass in as radians\r\n         * @param radians {number}\r\n         * @returns {number}\r\n         */\n        value: function RadiansToDegrees(radians) {\n            return radians * (180 / Math.PI);\n        }\n\n        /**\r\n         * @static DegreesToRadians() returns returns radians you pass in as degrees\r\n         * @param degrees {number}\r\n         * @returns {number}\r\n         */\n\n    }, {\n        key: \"DegreesToRadians\",\n        value: function DegreesToRadians(degrees) {\n            return degrees * (Math.PI / 180);\n        }\n\n        /**\r\n         * MapRange takes a set of values and maps another set of values to that range.\r\n         * @param value {number}\r\n         * @param bottomA {number}\r\n         * @param topA {number}\r\n         * @param bottomB {number}\r\n         * @param topB {number}\r\n         * @returns {number}\r\n         */\n\n    }, {\n        key: \"MapRange\",\n        value: function MapRange(value, bottomA, topA, bottomB, topB) {\n            return bottomB + (topB - bottomB) * (value - bottomA) / (topA - bottomA);\n        }\n    }]);\n    return Convert;\n}();\n\nvar Vector2 = function () {\n\tcreateClass(Vector2, null, [{\n\t\tkey: \"angleBetween\",\n\t\tvalue: function angleBetween(a, b) {\n\t\t\tvar mag = a.magnitude() * b.magnitude();\n\t\t\tvar dot = Vector2.dot(a, b);\n\t\t\treturn Math.acos(dot / mag);\n\t\t}\n\t}, {\n\t\tkey: \"lerp\",\n\t\tvalue: function lerp(a, b, t) {\n\t\t\tvar x = a.x + t * (b.x - a.x);\n\t\t\tvar y = a.y + t * (b.y - a.y);\n\t\t\treturn new Vector2(x, y);\n\t\t}\n\t}, {\n\t\tkey: \"normalize\",\n\t\tvalue: function normalize(vector) {\n\t\t\tvar vec = vector.get();\n\t\t\tvec.normalize();\n\t\t\treturn vec;\n\t\t}\n\t}, {\n\t\tkey: \"magnitude\",\n\t\tvalue: function magnitude(vec) {\n\t\t\treturn Math.sqrt(Vector2.dot(vec, vec));\n\t\t}\n\t}, {\n\t\tkey: \"add\",\n\t\tvalue: function add(a, b) {\n\t\t\treturn new Vector2(a.x + b.x, a.y + b.y);\n\t\t}\n\t}, {\n\t\tkey: \"subtract\",\n\t\tvalue: function subtract(a, b) {\n\t\t\tvar n = new Vector2(b.x, b.y);\n\t\t\tn.negate();\n\t\t\treturn Vector2.add(a, n);\n\t\t}\n\t}, {\n\t\tkey: \"multiply\",\n\t\tvalue: function multiply(a, scalar) {\n\t\t\treturn new Vector2(a.x * scalar, a.y * scalar);\n\t\t}\n\t}, {\n\t\tkey: \"divide\",\n\t\tvalue: function divide(a, scalar) {\n\t\t\tscalar = 1 / scalar;\n\t\t\treturn Vector2.multiply(a, scalar);\n\t\t}\n\t}, {\n\t\tkey: \"dot\",\n\t\tvalue: function dot(a, b) {\n\t\t\treturn a.x * b.x + a.y * b.y;\n\t\t}\n\t}, {\n\t\tkey: \"dist\",\n\t\tvalue: function dist(a, b) {\n\t\t\tvar vec1 = a.x - b.x;\n\t\t\tvar vec2 = a.y - b.y;\n\t\t\treturn Math.sqrt(vec1 * vec1 + vec2 * vec2);\n\t\t}\n\t}]);\n\n\tfunction Vector2() {\n\t\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t\tclassCallCheck(this, Vector2);\n\n\t\tthis.raw = [x, y];\n\t}\n\n\tcreateClass(Vector2, [{\n\t\tkey: \"get\",\n\t\tvalue: function get() {\n\t\t\treturn new Vector2(this.x, this.y);\n\t\t}\n\t}, {\n\t\tkey: \"set\",\n\t\tvalue: function set() {\n\t\t\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t\t\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}, {\n\t\tkey: \"multiply\",\n\t\tvalue: function multiply(scalar) {\n\t\t\tthis.x = this.x * scalar;\n\t\t\tthis.y = this.y * scalar;\n\t\t}\n\t}, {\n\t\tkey: \"add\",\n\t\tvalue: function add(v) {\n\t\t\tthis.x = this.x + v.x;\n\t\t\tthis.y = this.y + v.y;\n\t\t}\n\t}, {\n\t\tkey: \"subtract\",\n\t\tvalue: function subtract(v) {\n\t\t\tvar n = new Vector2(v.x, v.y);\n\t\t\tn.negate();\n\t\t\tthis.add(n);\n\t\t}\n\t}, {\n\t\tkey: \"divide\",\n\t\tvalue: function divide(scalar) {\n\t\t\tscalar = 1 / scalar;\n\t\t\tthis.multiply(scalar);\n\t\t}\n\t}, {\n\t\tkey: \"negate\",\n\t\tvalue: function negate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t}\n\t}, {\n\t\tkey: \"clamp\",\n\t\tvalue: function clamp(limit) {\n\t\t\tif (this.x > limit) {\n\t\t\t\tthis.x = limit;\n\t\t\t} else if (this.x < 0 && this.x < limit) {\n\t\t\t\tthis.x = -limit;\n\t\t\t}\n\t\t\tif (this.y > limit) {\n\t\t\t\tthis.y = limit;\n\t\t\t} else if (this.y < 0 && this.y < limit) {\n\t\t\t\tthis.y = -limit;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"limit\",\n\t\tvalue: function limit(_limit) {\n\t\t\tif (this.magnitude() > _limit) {\n\t\t\t\tthis.normalize();\n\t\t\t\tthis.multiply(_limit);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"rotate\",\n\t\tvalue: function rotate(degrees) {\n\t\t\tvar pivotVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(0, 0);\n\t\t\tvar stabilize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n\t\t\tvar mag = this.magnitude();\n\t\t\tvar rads = Convert.degreesToRadians(degrees);\n\t\t\tvar cosineAngle = Math.cos(rads);\n\t\t\tvar sineAngle = Math.sin(rads);\n\t\t\tthis.x = cosineAngle * (this.x - pivotVector.x) + sineAngle * (this.y - pivotVector.y) + pivotVector.x;\n\t\t\tthis.y = cosineAngle * (this.y - pivotVector.y) - sineAngle * (this.x - pivotVector.x) + pivotVector.y;\n\t\t\tif (stabilize) {\n\t\t\t\tthis.normalize();\n\t\t\t\tthis.multiply(mag);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"magnitude\",\n\t\tvalue: function magnitude() {\n\t\t\treturn Math.sqrt(Vector2.dot(this, this));\n\t\t}\n\t}, {\n\t\tkey: \"normalize\",\n\t\tvalue: function normalize() {\n\t\t\tvar m = this.magnitude();\n\t\t\tif (m > 0) {\n\t\t\t\tthis.divide(m);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"x\",\n\t\tget: function get() {\n\t\t\treturn this.raw[0];\n\t\t},\n\t\tset: function set(value) {\n\t\t\tthis.raw[0] = value;\n\t\t}\n\t}, {\n\t\tkey: \"y\",\n\t\tget: function get() {\n\t\t\treturn this.raw[1];\n\t\t},\n\t\tset: function set(value) {\n\t\t\tthis.raw[1] = value;\n\t\t}\n\t}, {\n\t\tkey: \"z\",\n\t\tget: function get() {\n\t\t\treturn 0;\n\t\t}\n\t}]);\n\treturn Vector2;\n}();\n\nvar Vector3 = function () {\n    createClass(Vector3, null, [{\n        key: \"reset\",\n\n\n        /**\r\n         * Resets the supplied Vector to 0.\r\n         * @param v {Vector3}\r\n         * @static\r\n         */\n        value: function reset(v) {\n            v.set(0, 0, 0, 0);\n        }\n\n        /**\r\n         * angleBetween() gets the angle between two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @returns {number}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"angleBetween\",\n        value: function angleBetween(a, b) {\n            var mag = a.magnitude() * b.magnitude();\n            var dot = Vector3.dot(a, b);\n            return Math.acos(dot / mag);\n        }\n\n        /**\r\n         * Linear interpolation between two vector locations\r\n         * @param a {Vector3} Starting point\r\n         * @param b {Vector3} Ending point\r\n         * @param t {number} The ratio between the two points 0: Start. 1: End.\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"lerp\",\n        value: function lerp(a, b, t) {\n            var v = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector3();\n\n            v.set(a.raw[0] + t * (b.raw[0] - a.raw[0]), a.raw[1] + t * (b.raw[1] - a.raw[1]), a.raw[2] + t * (b.raw[2] - a.raw[2]));\n            return v;\n        }\n\n        /**\r\n         * Normalize a Vector\r\n         * @param vector {Vector3}\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"normalize\",\n        value: function normalize(vector) {\n            var v = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n            var vec = vector.get(v);\n            vec.normalize();\n            return vec;\n        }\n\n        /**\r\n         * Get the Magnitude of a vector\r\n         * @param vector {Vector3}\r\n         * @returns {number}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"magnitude\",\n        value: function magnitude(vector) {\n            return Math.sqrt(Vector3.dot(vector, vector));\n        }\n\n        /**\r\n         * Add two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"add\",\n        value: function add(a, b) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            v.set(a.raw[0] + b.raw[0], a.raw[1] + b.raw[1], a.raw[2] + b.raw[2]);\n            return v;\n        }\n    }, {\n        key: \"subtract\",\n        value: function subtract(a, b) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            v.set(a.raw[0] - b.raw[0], a.raw[1] - b.raw[1], a.raw[2] - b.raw[2]);\n            return v;\n        }\n\n        /**\r\n         * Subtract two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"multiply\",\n        value: function multiply(a, scalar) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            v.set(a.raw[0] * scalar, a.raw[1] * scalar, a.raw[2] * scalar);\n            return v;\n        }\n\n        /**\r\n         * Multiply two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"divide\",\n        value: function divide(a, scalar) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            scalar = 1 / scalar;\n            v.set(a.raw[0] * scalar, a.raw[1] * scalar, a.raw[2] * scalar);\n            return v;\n        }\n\n        /**\r\n         * Gets the dot product of two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @returns {number}\r\n         * @static\r\n         */\n\n    }, {\n        key: \"dot\",\n        value: function dot(a, b) {\n            return a.raw[0] * b.raw[0] + a.raw[1] * b.raw[1] + a.raw[2] * b.raw[2];\n        }\n\n        /**\r\n         * Get the cross product of two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         */\n\n    }, {\n        key: \"cross\",\n        value: function cross(a, b) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            v.set(a.raw[1] * b.raw[2] - b.raw[1] * a.raw[2], a.raw[2] * b.raw[0] - b.raw[2] * a.raw[0], a.raw[0] * b.raw[1] - b.raw[0] * a.raw[1]);\n            return v;\n        }\n\n        /**\r\n         * Get the distance between two vectors\r\n         * @param a {Vector3}\r\n         * @param b {Vector3}\r\n         * @returns {number}\r\n         */\n\n    }, {\n        key: \"dist\",\n        value: function dist(a, b) {\n            var vec1 = a.raw[0] - b.raw[0];\n            var vec2 = a.raw[1] - b.raw[1];\n            var vec3 = a.raw[2] - b.raw[2];\n            return Math.sqrt(vec1 * vec1 + vec2 * vec2 + vec3 * vec3);\n        }\n\n        /**\r\n         * Creates a new Vector\r\n         * @param x {number}\r\n         * @param y {number}\r\n         * @param z {number}\r\n         * @param w {number}\r\n         * @constructor\r\n         */\n\n    }]);\n\n    function Vector3() {\n        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        classCallCheck(this, Vector3);\n\n        this.raw = new Float32Array(4);\n        this.raw[0] = x;\n        this.raw[1] = y;\n        this.raw[2] = z;\n        this.raw[3] = w;\n    }\n\n    createClass(Vector3, [{\n        key: \"get\",\n\n\n        /**\r\n         * Copy this vector\r\n         * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n         * @returns {Vector3}\r\n         */\n        value: function get() {\n            var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n\n            v.set(this.raw[0], this.raw[1], this.raw[2], this.raw[3]);\n            return v;\n        }\n\n        /**\r\n         * Sets the vector to the values passed in\r\n         * @param x {number}\r\n         * @param y {number}\r\n         * @param z {number}\r\n         * @param w {number}\r\n         */\n\n    }, {\n        key: \"set\",\n        value: function set() {\n            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n            this.raw[0] = x;\n            this.raw[1] = y;\n            this.raw[2] = z;\n            this.raw[3] = w;\n        }\n\n        /**\r\n         * Multiplies this vector by a scalar\r\n         * @param scalar {number}\r\n         */\n\n    }, {\n        key: \"multiply\",\n        value: function multiply(scalar) {\n            Vector3.multiply(this, scalar, this);\n        }\n\n        /**\r\n         * Adds the vector passed in to this vector\r\n         * @param v {Vector3}\r\n         */\n\n    }, {\n        key: \"add\",\n        value: function add(v) {\n            Vector3.add(this, v, this);\n        }\n\n        /**\r\n         * Subtracts the vector passed in from this vector\r\n         * @param v {Vector3}\r\n         */\n\n    }, {\n        key: \"subtract\",\n        value: function subtract(v) {\n            Vector3.subtract(this, v, this);\n        }\n\n        /**\r\n         * Divides this vector by the scalar\r\n         * @param scalar {Vector3}\r\n         */\n\n    }, {\n        key: \"divide\",\n        value: function divide(scalar) {\n            Vector3.divide(this, scalar, this);\n        }\n\n        /**\r\n         * Inverts this vector\r\n         */\n\n    }, {\n        key: \"negate\",\n        value: function negate() {\n            this.raw[0] = -this.raw[0];\n            this.raw[1] = -this.raw[1];\n            this.raw[2] = -this.raw[2];\n        }\n\n        /**\r\n         * Clamps the vector components to the limit value\r\n         * @param limit {number}\r\n         */\n\n    }, {\n        key: \"clamp\",\n        value: function clamp(limit) {\n            if (this.raw[0] > limit) {\n                this.raw[0] = limit;\n            } else if (this.raw[0] < 0 && this.raw[0] < limit) {\n                this.raw[0] = -limit;\n            }\n            if (this.raw[1] > limit) {\n                this.raw[1] = limit;\n            } else if (this.raw[1] < 0 && this.raw[1] < limit) {\n                this.raw[1] = -limit;\n            }\n            if (this.raw[2] > limit) {\n                this.raw[2] = limit;\n            } else if (this.raw[2] < 0 && this.raw[2] < limit) {\n                this.raw[2] = -limit;\n            }\n        }\n\n        /**\r\n         * limits the vector magnitude to the limit value\r\n         * @param limit {number} the maximum magnitude\r\n         */\n\n    }, {\n        key: \"limit\",\n        value: function limit(_limit) {\n            if (this.magnitude() > _limit) {\n                this.normalize();\n                this.multiply(_limit);\n            }\n        }\n\n        /**\r\n         * Rotate this vector\r\n         * @param degrees {number} degrees to rotate the vector by\r\n         * @param pivotVector {Vector3} [pivotVector= new Vector3()] The point that you want to rotate around (default 0,0)\r\n         * @param stabilize {boolean} [stabilize = false] stabilize the rotation of the vector by maintaining it's magnitude\r\n         */\n\n    }, {\n        key: \"rotate\",\n        value: function rotate(degrees) {\n            var pivotVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n            var stabilize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var mag = this.magnitude();\n            var rads = Convert.DegreesToRadians(degrees);\n            var cosineAngle = Math.cos(rads);\n            var sineAngle = Math.sin(rads);\n            this.raw[0] = cosineAngle * (this.raw[0] - pivotVector.x) + sineAngle * (this.raw[1] - pivotVector.y) + pivotVector.x;\n            this.raw[1] = cosineAngle * (this.raw[1] - pivotVector.y) - sineAngle * (this.raw[0] - pivotVector.x) + pivotVector.y;\n            if (stabilize) {\n                this.normalize();\n                this.multiply(mag);\n            }\n        }\n\n        /**\r\n         * The magnitude of this vector\r\n         * @returns {number}\r\n         */\n\n    }, {\n        key: \"magnitude\",\n        value: function magnitude() {\n            return Math.sqrt(Vector3.dot(this, this));\n        }\n\n        /**\r\n         * Normalize this vector\r\n         */\n\n    }, {\n        key: \"normalize\",\n        value: function normalize() {\n            var m = this.magnitude();\n            if (m > 0) {\n                this.divide(m);\n            }\n        }\n    }, {\n        key: \"x\",\n        get: function get() {\n            return this.raw[0];\n        },\n        set: function set(value) {\n            this.raw[0] = value;\n        }\n    }, {\n        key: \"y\",\n        get: function get() {\n            return this.raw[1];\n        },\n        set: function set(value) {\n            this.raw[1] = value;\n        }\n    }, {\n        key: \"z\",\n        get: function get() {\n            return this.raw[2];\n        },\n        set: function set(value) {\n            this.raw[2] = value;\n        }\n    }, {\n        key: \"w\",\n        get: function get() {\n            return this.raw[3];\n        },\n        set: function set(value) {\n            this.raw[3] = value;\n        }\n    }]);\n    return Vector3;\n}();\n\nvar Matrix3 = function () {\n\tfunction Matrix3() {\n\t\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\t\tclassCallCheck(this, Matrix3);\n\n\t\tthis.raw = new Float32Array(array);\n\t}\n\n\tcreateClass(Matrix3, [{\n\t\tkey: \"setMatrix\",\n\t\tvalue: function setMatrix(array) {\n\t\t\tthis.raw = array;\n\t\t}\n\t}, {\n\t\tkey: \"multiply\",\n\t\tvalue: function multiply(matrix) {\n\t\t\tvar newMatrix = Matrix3.multiply(this, matrix);\n\t\t\tthis.raw = newMatrix.raw;\n\t\t}\n\t}, {\n\t\tkey: \"column1\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[0], this.raw[3], this.raw[6]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[0] = array[0];\n\t\t\tthis.raw[3] = array[1];\n\t\t\tthis.raw[6] = array[2];\n\t\t}\n\t}, {\n\t\tkey: \"column2\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[1], this.raw[4], this.raw[7]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[1] = array[0];\n\t\t\tthis.raw[4] = array[1];\n\t\t\tthis.raw[7] = array[2];\n\t\t}\n\t}, {\n\t\tkey: \"column3\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[2], this.raw[5], this.raw[8]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[2] = array[0];\n\t\t\tthis.raw[5] = array[1];\n\t\t\tthis.raw[68] = array[2];\n\t\t}\n\t}, {\n\t\tkey: \"row1\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[0], this.raw[1], this.raw[2]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[0] = array[0];\n\t\t\tthis.raw[1] = array[1];\n\t\t\tthis.raw[2] = array[2];\n\t\t}\n\t}, {\n\t\tkey: \"row2\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[3], this.raw[4], this.raw[5]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[3] = array[0];\n\t\t\tthis.raw[4] = array[1];\n\t\t\tthis.raw[5] = array[2];\n\t\t}\n\t}, {\n\t\tkey: \"row3\",\n\t\tget: function get() {\n\t\t\treturn [this.raw[6], this.raw[7], this.raw[8]];\n\t\t},\n\t\tset: function set(array) {\n\t\t\tthis.raw[6] = array[0];\n\t\t\tthis.raw[7] = array[1];\n\t\t\tthis.raw[8] = array[2];\n\t\t}\n\t}], [{\n\t\tkey: \"dot\",\n\t\tvalue: function dot(a, b) {\n\t\t\tvar dots = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n\t\t\tconsole.log(dots);\n\t\t\treturn dots;\n\t\t}\n\t}, {\n\t\tkey: \"multiply\",\n\t\tvalue: function multiply(a, b) {\n\t\t\tvar matrix = new Float32Array(9);\n\t\t\tmatrix[0] = Matrix3.dot(a.column1, b.row1);\n\t\t\tmatrix[1] = Matrix3.dot(a.column2, b.row1);\n\t\t\tmatrix[2] = Matrix3.dot(a.column3, b.row1);\n\t\t\tmatrix[3] = Matrix3.dot(a.column1, b.row2);\n\t\t\tmatrix[4] = Matrix3.dot(a.column2, b.row2);\n\t\t\tmatrix[5] = Matrix3.dot(a.column3, b.row2);\n\t\t\tmatrix[6] = Matrix3.dot(a.column1, b.row3);\n\t\t\tmatrix[7] = Matrix3.dot(a.column2, b.row3);\n\t\t\tmatrix[8] = Matrix3.dot(a.column3, b.row3);\n\t\t\tvar newMatrix = new Matrix3();\n\t\t\tnewMatrix.setMatrix(matrix);\n\t\t\treturn newMatrix;\n\t\t}\n\t}]);\n\treturn Matrix3;\n}();\n\nvar Matrix4 = function () {\n    function Matrix4() {\n        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Matrix4.identity();\n        classCallCheck(this, Matrix4);\n\n        this.setMatrix(array);\n    }\n\n    createClass(Matrix4, [{\n        key: \"setMatrix\",\n        value: function setMatrix(array) {\n            this.raw = array;\n        }\n    }, {\n        key: \"transpose\",\n        value: function transpose() {\n            var row1 = [this.raw[0], this.raw[1], this.raw[2], this.raw[3]];\n            var row2 = [this.raw[4], this.raw[5], this.raw[6], this.raw[7]];\n            var row3 = [this.raw[8], this.raw[9], this.raw[10], this.raw[11]];\n            var row4 = [this.raw[12], this.raw[13], this.raw[14], this.raw[15]];\n\n            this.raw[0] = row1[0];\n            this.raw[4] = row1[1];\n            this.raw[8] = row1[2];\n            this.raw[12] = row1[3];\n\n            this.raw[1] = row2[0];\n            this.raw[5] = row2[1];\n            this.raw[9] = row2[2];\n            this.raw[13] = row2[3];\n\n            this.raw[2] = row3[0];\n            this.raw[6] = row3[1];\n            this.raw[10] = row3[2];\n            this.raw[14] = row3[3];\n\n            this.raw[3] = row4[0];\n            this.raw[7] = row4[1];\n            this.raw[11] = row4[2];\n            this.raw[15] = row4[3];\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(matrix) {\n            Matrix4.multiply(this, matrix, this);\n        }\n    }], [{\n        key: \"identity\",\n        value: function identity() {\n            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n        }\n    }, {\n        key: \"dot\",\n        value: function dot(c1, c2, c3, c4, r1, r2, r3, r4) {\n            return c1 * r1 + c2 * r2 + c3 * r3 + c4 * r4;\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(a, b) {\n            var outputMatrix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Matrix4();\n\n            var matrix = new Float32Array(16);\n            //let matrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n            matrix[0] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\n            matrix[1] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\n            matrix[2] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\n            matrix[3] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\n\n            matrix[4] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\n            matrix[5] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\n            matrix[6] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\n            matrix[7] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\n\n            matrix[8] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\n            matrix[9] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\n            matrix[10] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\n            matrix[11] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\n\n            matrix[12] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\n            matrix[13] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\n            matrix[14] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\n            matrix[15] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\n            //console.log(outputMatrix);\n            outputMatrix.setMatrix(matrix);\n            return outputMatrix;\n        }\n    }, {\n        key: \"multiplyVector\",\n        value: function multiplyVector(v3, matrix) {\n            var v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n            v.set(matrix[0] * v3.raw[0], matrix[1] * v3.raw[1], matrix[2] * v3.raw[2], matrix[3] * v3.raw[3], matrix[4] * v3.raw[0], matrix[5] * v3.raw[1], matrix[6] * v3.raw[2], matrix[7] * v3.raw[3], matrix[8] * v3.raw[0], matrix[9] * v3.raw[1], matrix[10] * v3.raw[2], matrix[11] * v3.raw[3], matrix[12] * v3.raw[0], matrix[13] * v3.raw[1], matrix[14] * v3.raw[2], matrix[15] * v3.raw[3]);\n            return v;\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(v3) {}\n    }, {\n        key: \"scale\",\n        value: function scale(v3) {}\n    }]);\n    return Matrix4;\n}();\n\nvar hexString = \"0123456789abcdef\";\n\nvar Generate = function () {\n    function Generate() {\n        classCallCheck(this, Generate);\n    }\n\n    createClass(Generate, null, [{\n        key: \"RandomHexString\",\n        value: function RandomHexString(length) {\n            var bytes = \"\";\n            for (var i = 0; i < length; i++) {\n                bytes += hexString.substr(Math.floor(Math.random() * hexString.length), 1);\n            }\n            return bytes;\n        }\n    }, {\n        key: \"UUID\",\n        value: function UUID() {\n            return Generate.RandomHexString(8) + \"-\" + Generate.RandomHexString(4) + \"-\" + Generate.RandomHexString(4) + \"-\" + Generate.RandomHexString(4) + \"-\" + Generate.RandomHexString(12);\n        }\n    }]);\n    return Generate;\n}();\n\nvar pools = new Object();\nvar objectPool = new Object();\nvar usagePool = new Object();\nvar clean = new Object();\n\nvar Pool = function () {\n    function Pool() {\n        classCallCheck(this, Pool);\n    }\n\n    createClass(Pool, null, [{\n        key: \"allocate\",\n        value: function allocate(object, objectKey, number) {\n            var cleaner = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (item) {\n                return item;\n            };\n\n\n            if (object.hasOwnProperty(\"prototype\")) {\n                pools[objectKey] = {\n                    object: object,\n                    objectKey: objectKey,\n                    amount: number,\n                    cleaner: cleaner\n                };\n                clean[objectKey] = cleaner;\n                usagePool[objectKey] = [];\n                objectPool[objectKey] = [];\n                for (var i = 0; i < number; i++) {\n                    var instance = new object();\n                    instance.v_pool_index = i;\n                    instance.v_pool_key = objectKey;\n                    usagePool[objectKey][i] = false;\n                    objectPool[objectKey][i] = instance;\n                }\n                return objectPool[objectKey];\n            } else {\n                throw new Error(\"Object must have a constructor\");\n            }\n        }\n    }, {\n        key: \"deallocate\",\n        value: function deallocate(objectKey) {\n            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            if (Pool.referencesInPool(objectKey) == 0 || force == true) {\n                delete clean[objectKey];\n                delete usagePool[objectKey];\n                delete objectPool[objectKey];\n                delete pools[objectKey];\n            } else {\n                console.warn(\"You still have objects in this pool checked out. Return them and call deallocate. Or use deallocate(key, true) to force deallocation.\");\n            }\n        }\n    }, {\n        key: \"referencesInPool\",\n        value: function referencesInPool(objectKey) {\n            return pools[objectKey].amount - Pool.poolsize(objectKey);\n        }\n    }, {\n        key: \"poolsize\",\n        value: function poolsize(objectKey) {\n            return objectPool[objectKey].filter(Pool.notInUse).length;\n        }\n    }, {\n        key: \"inUse\",\n        value: function inUse(object) {\n            return usagePool[object.v_pool_key][object.v_pool_index];\n        }\n    }, {\n        key: \"notInUse\",\n        value: function notInUse(object) {\n            return !usagePool[object.v_pool_key][object.v_pool_index];\n        }\n    }, {\n        key: \"returnAll\",\n        value: function returnAll(objectKey) {\n            var objects = objectPool[objectKey].filter(Pool.inUse);\n            for (var i = 0; i < objects.length; i++) {\n                Pool.returnObject(objects[i]);\n            }\n        }\n    }, {\n        key: \"getObject\",\n        value: function getObject(objectKey) {\n            var i = usagePool[objectKey].indexOf(false);\n            usagePool[objectKey][i] = true;\n            if (i > -1) {\n                return objectPool[objectKey][i];\n            } else {\n                throw new Error(\"Out of objects\");\n            }\n        }\n    }, {\n        key: \"returnObject\",\n        value: function returnObject(obj) {\n            clean[obj.v_pool_key](obj);\n            usagePool[obj.v_pool_key][obj.v_pool_index] = false;\n        }\n    }, {\n        key: \"returnObjects\",\n        value: function returnObjects(objs) {\n            for (var i = 0; i < objs.length; i++) {\n                Pool.returnObject(objs[i]);\n            }\n        }\n    }, {\n        key: \"Pools\",\n        get: function get() {\n            return pools;\n        }\n    }]);\n    return Pool;\n}();\n\nvar listeners = {};\n\nvar EventLite = function () {\n    function EventLite() {\n        classCallCheck(this, EventLite);\n    }\n\n    createClass(EventLite, null, [{\n        key: \"on\",\n        value: function on(event, handler) {\n            if (listeners[event] === undefined) {\n                listeners[event] = [handler];\n            } else {\n                listeners[event].push(handler);\n            }\n            return handler;\n        }\n    }, {\n        key: \"off\",\n        value: function off(event, handler) {\n            if (listeners[event]) {\n                for (var i = listeners[event].length - 1; i >= 0; i--) {\n                    if (listeners[event].length === 1) {\n                        delete listeners[event];\n                    } else {\n                        listeners[event].splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"trigger\",\n        value: function trigger(event) {\n            if (listeners[event]) {\n                for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                    data[_key - 1] = arguments[_key];\n                }\n\n                for (var i = listeners[event].length - 1; i >= 0; i--) {\n                    if (listeners[event] !== undefined) {\n                        if (typeof listeners[event][i] === \"function\" && listeners[event][i]) {\n                            listeners[event][i](data);\n                        } else {\n                            throw \"Event handler is not a function.\";\n                        }\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"unbindAll\",\n        value: function unbindAll() {\n            for (var event in listeners) {\n                delete listeners[event];\n            }\n            return true;\n        }\n    }]);\n    return EventLite;\n}();\n\nvar resizeId;\nvar resizeEvent;\n\nvar Screen = function () {\n    function Screen() {\n        classCallCheck(this, Screen);\n    }\n\n    createClass(Screen, null, [{\n        key: \"resize\",\n        value: function resize(e) {\n            clearTimeout(resizeId);\n            resizeEvent = e;\n            resizeId = setTimeout(Screen.recalculate, Screen.resizeDelay);\n        }\n    }, {\n        key: \"recalculate\",\n        value: function recalculate() {\n            Screen.dimensions.set(window.innerWidth, window.innerHeight);\n            if (Screen.dimensions.x > Screen.dimensions.y) {\n                Screen.orientation = \"landscape\";\n            } else {\n                Screen.orientation = \"portrait\";\n            }\n            for (var anchor in Screen.anchors) {\n                if (Screen.anchors.hasOwnProperty(anchor)) {\n                    Screen.anchorPositions[anchor].set(Screen.anchors[anchor].x * Screen.dimensions.x, Screen.anchors[anchor].y * Screen.dimensions.y);\n                }\n            }\n\n            EventLite.trigger(\"resize\", resizeEvent);\n        }\n    }, {\n        key: \"getAnchor\",\n        value: function getAnchor(name) {\n            return Screen.anchorPositions[name].get();\n        }\n    }, {\n        key: \"setAnchor\",\n        value: function setAnchor(name, ratioX, ratioY) {\n\n            if (Screen.anchors[name] == undefined) {\n                Screen.anchors[name] = new Vector3(ratioX, ratioY);\n                Screen.anchorPositions[name] = new Vector3(Screen.anchors[name].x * Screen.dimensions.x, Screen.anchors[name].y * Screen.dimensions.y);\n            } else {\n                Screen.anchors[name].set(ratioX, ratioY);\n                Screen.anchorPositions[name].set(Screen.anchors[name].x * Screen.dimensions.x, Screen.anchors[name].y * Screen.dimensions.y);\n            }\n        }\n    }, {\n        key: \"removeAnchor\",\n        value: function removeAnchor(name) {\n            delete Screen.anchors[name];\n            delete Screen.anchorPositions[name];\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            Screen.resizeDelay = 100;\n            Screen.anchors = {};\n            Screen.anchorPositions = {};\n            Screen.dimensions = new Vector3(window.innerWidth, window.innerHeight);\n            Screen.setAnchor(\"center\", 0.5, 0.5);\n            if (Screen.dimensions.x > Screen.dimensions.y) {\n                Screen.orientation = \"landscape\";\n            } else {\n                Screen.orientation = \"portrait\";\n            }\n        }\n    }, {\n        key: \"dimensions\",\n        get: function get() {\n            return Screen._dimensions;\n        },\n        set: function set(value) {\n            if (Screen._dimensions != value) {\n                Screen._dimensions = value;\n            }\n        }\n    }, {\n        key: \"orientation\",\n        get: function get() {\n            return Screen._orientation;\n        },\n        set: function set(value) {\n            if (Screen._orientation != value) {\n                Screen._orientation = value;\n            }\n        }\n    }, {\n        key: \"center\",\n        get: function get() {\n            return Screen._center;\n        },\n        set: function set(value) {\n            if (Screen._center != value) {\n                Screen._center = value;\n            }\n        }\n    }, {\n        key: \"resizeDelay\",\n        get: function get() {\n            return Screen._resizeDelay;\n        },\n        set: function set(value) {\n            if (Screen._resizeDelay != value) {\n                Screen._resizeDelay = value;\n            }\n        }\n    }, {\n        key: \"anchors\",\n        get: function get() {\n            return Screen._anchors;\n        },\n        set: function set(value) {\n            if (Screen._anchors != value) {\n                Screen._anchors = value;\n            }\n        }\n    }, {\n        key: \"anchorPositions\",\n        get: function get() {\n            return Screen._anchorPositions;\n        },\n        set: function set(value) {\n            if (Screen._anchorPositions != value) {\n                Screen._anchorPositions = value;\n            }\n        }\n    }, {\n        key: \"width\",\n        get: function get() {\n            return Screen._dimensions.x;\n        }\n    }, {\n        key: \"height\",\n        get: function get() {\n            return Screen._dimensions.y;\n        }\n    }]);\n    return Screen;\n}();\n\nScreen.init();\n\n/**\r\n * Behaviors are applied to Actors by passing actors, target actors, and parameters into them.\r\n * @class Behaviors\r\n */\nvar key = Generate.UUID();\n\nvar Behavior = function () {\n    function Behavior() {\n        classCallCheck(this, Behavior);\n    }\n\n    createClass(Behavior, null, [{\n        key: \"init\",\n\n        /**\r\n         * init is a static method that is used to initialize the object pool\r\n         */\n        value: function init() {\n            Pool.allocate(Vector3, key, 10, Vector3.reset);\n        }\n\n        /**\r\n         * seek() finds the distance between the actor and the targetLcation and applys a force to move the actor toward that target.\r\n         * @param actor {Actor}\r\n         * @param targetPosition {Vector3}\r\n         * @param scaleForce {?number}\r\n         */\n\n    }, {\n        key: \"seek\",\n        value: function seek(actor, targetPosition) {\n            var scaleForce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n            var desired = Pool.getObject(key);\n            var steer = Pool.getObject(key);\n\n            Vector3.subtract(targetPosition, actor.location, desired);\n            desired.normalize();\n            desired.multiply(actor.maxSpeed);\n            Vector3.subtract(desired, actor.velocity, steer);\n\n            steer.limit(actor.maxForce);\n            steer.multiply(scaleForce);\n            actor.addForce(steer);\n\n            Pool.returnObject(desired);\n            Pool.returnObject(steer);\n        }\n\n        /**\r\n         * arrive() works similarly to seek, but with the magnitude of the seek mapped to a power that is inversely proportionate to the magnitude of the distance between the actor and the target.\r\n         * @param actor {Actor}\r\n         * @param target {Vector3}\r\n         * @param power {?number}\r\n         * @param scaleForce {?number}\r\n         */\n\n    }, {\n        key: \"arrive\",\n        value: function arrive(actor, target) {\n            var power = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 50;\n            var scaleForce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n            var desired = Pool.getObject(key);\n            var steer = Pool.getObject(key);\n            Vector3.subtract(target, actor.location, desired);\n            var mappedPower = Convert.MapRange(desired.magnitude(), 0, power, 0, actor.maxSpeed);\n            desired.normalize();\n            desired.multiply(mappedPower);\n            Vector3.subtract(desired, actor.velocity, steer);\n            steer.limit(actor.maxForce);\n            steer.multiply(scaleForce);\n            actor.addForce(steer);\n            Pool.returnObject(desired);\n            Pool.returnObject(steer);\n        }\n\n        /**\r\n         * avoidAll() takes an array of obstacle actors and for each obstacle, the Actor will have the average escape vector of all the obstacles near it applied to it.\r\n         * @param actor {Actor}\r\n         * @param obstacles {Array.<Actor>}\r\n         * @param avoidRadius {?number}\r\n         * @param scaleForce {?number}\r\n         */\n\n    }, {\n        key: \"avoidAll\",\n        value: function avoidAll(actor, obstacles) {\n            var avoidRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n            var scaleForce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n            var difference = Pool.getObject(key);\n            var steer = Pool.getObject(key);\n            var total = Pool.getObject(key);\n            var count = 0;\n            for (var o = 0; o < obstacles.length; o++) {\n                var obstacle = obstacles[o];\n                var distance = Vector3.dist(actor.location, obstacle.location);\n                if (distance > 0 && distance < avoidRadius && actor.id != obstacle.id) {\n                    Vector3.subtract(actor.location, obstacle.location, difference);\n                    difference.normalize();\n                    difference.divide(distance);\n                    total.add(difference);\n                    count++;\n                }\n            }\n            if (count > 0) {\n                total.divide(count);\n                total.normalize();\n                total.multiply(actor.maxSpeed);\n                Vector3.subtract(total, actor.velocity, steer);\n                steer.limit(actor.maxForce);\n                steer.multiply(scaleForce);\n                actor.addForce(steer);\n            }\n            Pool.returnObject(difference);\n            Pool.returnObject(steer);\n            Pool.returnObject(total);\n        }\n\n        /**\r\n         * Uses a single obstacle in the avoidAll function\r\n         * @param actor\r\n         * @param target\r\n         * @param avoidRadius\r\n         */\n\n    }, {\n        key: \"avoid\",\n        value: function avoid(actor, target, avoidRadius) {\n            this.avoidAll(actor, [target], avoidRadius);\n        }\n\n        /**\r\n         * constrain() will lock your actor to the provided area. Velocity will be inverted with no friction when an Actor hits the wall.\r\n         * @param actor {Actor}\r\n         * @param minWidth {number} Left\r\n         * @param minHeight {number} Uo\r\n         * @param maxWidth {number} Right\r\n         * @param maxHeight {number} Bottom\r\n         * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n         */\n\n    }, {\n        key: \"constrain\",\n        value: function constrain(actor) {\n            var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Screen.width;\n            var maxHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Screen.height;\n            var margin = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n            minWidth -= margin;\n            maxWidth += margin;\n            minHeight -= margin;\n            maxHeight += margin;\n\n            if (actor.location.x < minWidth) {\n                actor.velocity.x *= -1;\n                actor.location.x = minWidth;\n            }\n            if (actor.location.y < minHeight) {\n                actor.velocity.y *= -1;\n                actor.location.y = minHeight;\n            }\n            if (actor.location.x > maxWidth) {\n\n                actor.velocity.x *= -1;\n                actor.location.x = maxWidth;\n            }\n            if (actor.location.y > maxHeight) {\n                actor.velocity.y *= -1;\n                actor.location.y = maxHeight;\n            }\n        }\n\n        /**\r\n         * wrap() will teleport your object to the opposite side of the screen where it left\r\n         * @param actor {Actor}\r\n         * @param minWidth {number} Left\r\n         * @param minHeight {number} Uo\r\n         * @param maxWidth {number} Right\r\n         * @param maxHeight {number} Bottom\r\n         * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n         */\n\n    }, {\n        key: \"wrap\",\n        value: function wrap(actor) {\n            var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var minHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Screen.width;\n            var maxHeight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Screen.height;\n            var margin = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n            minWidth -= margin;\n            maxWidth += margin;\n            minHeight -= margin;\n            maxHeight += margin;\n\n            if (actor.location.x < minWidth) {\n                actor.location.x = maxWidth;\n            }\n            if (actor.location.y < minHeight) {\n                actor.location.y = maxHeight;\n            }\n            if (actor.location.x > maxWidth) {\n                actor.location.x = minWidth;\n            }\n            if (actor.location.y > maxHeight) {\n                actor.location.y = minHeight;\n            }\n        }\n\n        /**\r\n         * disableOutside will set your Actor.active parameter to \"false\" when it leaves the defined area\r\n         * @param actor {Actor}\r\n         * @param minWidth {number} Left\r\n         * @param minHeight {number} Uo\r\n         * @param maxWidth {number} Right\r\n         * @param maxHeight {number} Bottom\r\n         * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n         */\n\n    }, {\n        key: \"disableOutside\",\n        value: function disableOutside(actor, minWidth, minHeight, maxWidth, maxHeight) {\n            var margin = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n            minWidth -= margin;\n            maxWidth += margin;\n            minHeight -= margin;\n            maxHeight += margin;\n\n            if (actor.location.x < minWidth || actor.location.y < minHeight || actor.location.x > maxWidth || actor.location.y > maxHeight) {\n                actor.active = false;\n                actor.visible = false;\n            }\n        }\n\n        /**\r\n         * destroyOutside will set Actor.dead to true if it leaves the defined area;\r\n         * @param actor {Actor}\r\n         * @param minWidth {number} Left\r\n         * @param minHeight {number} Uo\r\n         * @param maxWidth {number} Right\r\n         * @param maxHeight {number} Bottom\r\n         * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n         */\n\n    }, {\n        key: \"destroyOutside\",\n        value: function destroyOutside(actor, minWidth, minHeight, maxWidth, maxHeight) {\n            var margin = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n            minWidth -= margin;\n            maxWidth += margin;\n            minHeight -= margin;\n            maxHeight += margin;\n            if (actor.location.x < minWidth || actor.location.y < minHeight || actor.location.x > maxWidth || actor.location.y > maxHeight) {\n                actor.dead = true;\n            }\n        }\n    }]);\n    return Behavior;\n}();\n\nBehavior.init();\n\n/**\r\n *    The Actor class is used by Behaviors to apply behaviors to.\r\n *  @Class Actor\r\n */\n\nvar Actor = function () {\n    /**\r\n     * @constructor\r\n     * @param className {string}\r\n     * @param location {Vector3)\r\n     */\n    function Actor() {\n        var className = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Actor\";\n        var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, 0);\n        classCallCheck(this, Actor);\n\n        this.type = className;\n        this.active = true;\n        this.visible = true;\n        this.dead = false;\n        this.id = Generate.UUID();\n        this.location = location;\n        this.velocity = new Vector3(0, 0, 0);\n        this.acceleration = new Vector3(0, 0, 0);\n        this.angle = 0;\n        this.maxSpeed = 15;\n        this.maxForce = 1;\n    }\n\n    /**\r\n     * addForce() will add the vector you pass in to the acceleration\r\n     * @param vector {Vector3}\r\n     */\n\n\n    createClass(Actor, [{\n        key: \"addForce\",\n        value: function addForce(vector) {\n            this.acceleration.add(vector);\n        }\n\n        /**\r\n         * update() will check to see if this actor is active, then call move(), then add the acceleration to the velocity, the velocity to the location, then reset the acceleration.\r\n         */\n\n    }, {\n        key: \"update\",\n        value: function update() {\n            if (this.active) {\n                this.move();\n                this.velocity.add(this.acceleration);\n                this.location.add(this.velocity);\n                this.acceleration.set(0, 0, 0);\n            }\n        }\n\n        /**\r\n         * move() is unused in the base class and is designed to be overridden. Anything in the move function will be applied before acceleration is added to velocity. See DOMActor for an example.\r\n         */\n\n    }, {\n        key: \"move\",\n        value: function move() {}\n\n        /**\r\n         * render() checks if the actor is visible then calls the draw() function. See DOMActor for an example.\r\n         */\n\n    }, {\n        key: \"render\",\n        value: function render() {\n            if (this.visible) {\n                this.draw();\n            }\n        }\n\n        /**\r\n         * draw() is empty in this class but can be extended to render itself in any rendering environment of your choice. See DOMActor for an example.\r\n         */\n\n    }, {\n        key: \"draw\",\n        value: function draw() {}\n        // override this function win your drawing code\n\n\n        /**\r\n         * destroy() sets the Actor.dead state to true. This is used by the GameLoop class to clean up / remove dead objects.\r\n         */\n\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this.dead = true;\n        }\n    }]);\n    return Actor;\n}();\n\n/**\r\n * DOMActor is an extension of the Actor class specifically for working with DOM elements.\r\n * @class DOMActor\r\n * @extends Actor\r\n */\n\nvar DOMActor = function (_Actor) {\n    inherits(DOMActor, _Actor);\n\n    /**\r\n     * @param className {string} the CSS class you want to use for this DOMActor\r\n     * @param location {Vector3} The starting location for this Actor\r\n     * @constructor\r\n     */\n    function DOMActor(className, location) {\n        classCallCheck(this, DOMActor);\n\n        var _this = possibleConstructorReturn(this, (DOMActor.__proto__ || Object.getPrototypeOf(DOMActor)).call(this, className, location));\n\n        _this.element = document.createElement(\"div\");\n        _this.element.classList.add(\"actor\");\n        _this.element.classList.add(className);\n        _this.parentElement = null;\n        return _this;\n    }\n\n    /**\r\n     * addToParentElement() will add DOMActor.element to the parentElement\r\n     * @param parentElement {HTMLElement}\r\n     */\n\n\n    createClass(DOMActor, [{\n        key: \"addToParentElement\",\n        value: function addToParentElement(parentElement) {\n            this.parentElement = parentElement;\n            this.parentElement.appendChild(this.element);\n        }\n\n        /**\r\n         * draw() sets this DOMActor.element.style.transform to `translateX(${this.location.x}px) translateY(${this.location.y}px) rotate(${this.angle}deg)`\r\n         */\n\n    }, {\n        key: \"draw\",\n        value: function draw() {\n            this.element.style.transform = \"translateX(\" + this.location.x + \"px) translateY(\" + this.location.y + \"px) rotate(\" + this.angle + \"deg)\";\n        }\n\n        /**\r\n         * destroy() sets this DOMActor to dead, removes it from the DOM, and nulls its reference to the parentElement\r\n         */\n\n    }, {\n        key: \"destroy\",\n        value: function destroy() {\n            this.dead = true;\n            this.element.remove();\n            this.parentElement = null;\n        }\n    }]);\n    return DOMActor;\n}(Actor);\n\nvar GameLoop = function () {\n\tfunction GameLoop() {\n\t\tclassCallCheck(this, GameLoop);\n\n\t\tthis.gameObjects = [];\n\t\tthis.controller = [];\n\t}\n\n\tcreateClass(GameLoop, [{\n\t\tkey: \"setController\",\n\t\tvalue: function setController(inputController) {\n\t\t\tthis.controller.push(inputController);\n\t\t}\n\t}, {\n\t\tkey: \"getType\",\n\t\tvalue: function getType(type) {\n\t\t\tvar matches = [];\n\t\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\n\t\t\t\tif (this.gameObjects[i].type === type) {\n\t\t\t\t\tmatches.push(this.gameObjects[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t}, {\n\t\tkey: \"update\",\n\t\tvalue: function update() {\n\t\t\tthis.removeActors();\n\t\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\n\t\t\t\tthis.gameObjects[i].update();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"addActor\",\n\t\tvalue: function addActor(actor) {\n\t\t\tthis.gameObjects.push(actor);\n\t\t}\n\t}, {\n\t\tkey: \"removeActors\",\n\t\tvalue: function removeActors() {\n\t\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\n\t\t\t\tif (this.gameObjects[i].dead) {\n\t\t\t\t\tthis.gameObjects.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"render\",\n\t\tvalue: function render() {\n\t\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\n\t\t\t\tthis.gameObjects[i].render();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"loop\",\n\t\tvalue: function loop() {\n\t\t\tthis.update();\n\t\t\tthis.render();\n\t\t\twindow.requestAnimationFrame(this.loop.bind(this));\n\t\t}\n\t}]);\n\treturn GameLoop;\n}();\n\nvar InputController = function () {\n    function InputController() {\n        classCallCheck(this, InputController);\n\n        this.keyMap = {};\n        this.mousePos = new Vector3();\n    }\n\n    createClass(InputController, [{\n        key: \"bindEvents\",\n        value: function bindEvents() {\n            document.addEventListener(\"mouseup\", this.setMouseUp.bind(this));\n            document.addEventListener(\"mousedown\", this.setMouseDown.bind(this));\n            document.addEventListener(\"mousemove\", this.setMousePos.bind(this));\n            onkeydown = onkeyup = this.mapKeys.bind(this);\n        }\n    }, {\n        key: \"unbindEvents\",\n        value: function unbindEvents() {\n            document.removeEventListener(\"mouseup\", this.setMouseUp.bind(this));\n            document.removeEventListener(\"mousedown\", this.setMouseDown.bind(this));\n            document.removeEventListener(\"mousemove\", this.setMousePos.bind(this));\n            onkeydown = onkeyup = null;\n        }\n    }, {\n        key: \"setMousePos\",\n        value: function setMousePos(e) {\n            this.mousePos.set(e.pageX, e.pageY);\n        }\n    }, {\n        key: \"setMouseUp\",\n        value: function setMouseUp(e) {\n            var fakeKey = {\n                key: \"mouse\" + e.button,\n                type: \"keyup\"\n            };\n            this.mapKeys(fakeKey);\n        }\n    }, {\n        key: \"setMouseDown\",\n        value: function setMouseDown(e) {\n            var fakeKey = {\n                key: \"mouse\" + e.button,\n                type: \"keydown\"\n            };\n            this.mapKeys(fakeKey);\n        }\n    }, {\n        key: \"mapKeys\",\n        value: function mapKeys(e) {\n            e = e || event;\n            this.keyMap[e.key] = e.type == 'keydown';\n        }\n    }, {\n        key: \"keyUp\",\n        value: function keyUp(key) {\n            console.log(key);\n        }\n    }, {\n        key: \"keyDown\",\n        value: function keyDown(key) {\n            console.log(key);\n        }\n    }, {\n        key: \"setKeys\",\n        value: function setKeys() {\n            for (var key in this.keyMap) {\n                if (this.keyMap[key]) {\n                    this.keyDown(key);\n                } else {\n                    this.keyUp(key);\n                }\n            }\n        }\n    }]);\n    return InputController;\n}();\n\n/**\r\n * Main.js\r\n */\n\nexports.Vector2 = Vector2;\nexports.Vector3 = Vector3;\nexports.Matrix3 = Matrix3;\nexports.Matrix4 = Matrix4;\nexports.Behaviors = Behavior;\nexports.Actor = Actor;\nexports.DOMActor = DOMActor;\nexports.GameLoop = GameLoop;\nexports.Screen = Screen;\nexports.InputController = InputController;\nexports.EventLite = EventLite;\nexports.Pool = Pool;\nexports.Convert = Convert;\nexports.Generate = Generate;\n"],"file":"vexr.cjs.js"}