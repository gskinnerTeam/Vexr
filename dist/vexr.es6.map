{"version":3,"names":[],"mappings":"","sources":["vexr.es6.js"],"sourcesContent":["/**\r\n * Small library of converters needed for the various Vexr operations\r\n * @class Convert\r\n */\r\n\r\nclass Convert {\r\n    /**\r\n     * @static RadiansToDegrees() returns degrees you pass in as radians\r\n     * @param radians {number}\r\n     * @returns {number}\r\n     */\r\n    static RadiansToDegrees(radians) {\r\n        return radians * (180 / Math.PI);\r\n    }\r\n\r\n    /**\r\n     * @static DegreesToRadians() returns returns radians you pass in as degrees\r\n     * @param degrees {number}\r\n     * @returns {number}\r\n     */\r\n    static DegreesToRadians(degrees) {\r\n        return degrees * (Math.PI / 180);\r\n    }\r\n\r\n    /**\r\n     * MapRange takes a set of values and maps another set of values to that range.\r\n     * @param value {number}\r\n     * @param bottomA {number}\r\n     * @param topA {number}\r\n     * @param bottomB {number}\r\n     * @param topB {number}\r\n     * @returns {number}\r\n     */\r\n    static MapRange(value, bottomA, topA, bottomB, topB) {\r\n        return bottomB + (topB - bottomB) * (value - bottomA) / (topA - bottomA);\r\n    }\r\n\r\n}\n\nclass Vector2 {\r\n\r\n\tstatic angleBetween(a, b) {\r\n\t\tvar mag = a.magnitude() * b.magnitude();\r\n\t\tvar dot = Vector2.dot(a, b);\r\n\t\treturn Math.acos(dot / mag);\r\n\t}\r\n\r\n\tstatic lerp(a, b, t) {\r\n\t\tvar x = a.x + t * (b.x - a.x);\r\n\t\tvar y = a.y + t * (b.y - a.y);\r\n\t\treturn new Vector2(x, y);\r\n\t}\r\n\r\n\tstatic normalize(vector) {\r\n\t\tvar vec = vector.get();\r\n\t\tvec.normalize();\r\n\t\treturn vec;\r\n\t}\r\n\r\n\tstatic magnitude(vec) {\r\n\t\t\treturn Math.sqrt(Vector2.dot(vec, vec));\r\n\t}\r\n\r\n\tstatic add(a, b) {\r\n\t\treturn new Vector2((a.x + b.x), (a.y + b.y));\r\n\t}\r\n\r\n\tstatic subtract(a, b) {\r\n\t\tvar n = new Vector2(b.x, b.y);\r\n\t\tn.negate();\r\n\t\treturn Vector2.add(a, n);\r\n\t}\r\n\r\n\tstatic multiply(a, scalar) {\r\n\t\treturn new Vector2(a.x * scalar, a.y * scalar);\r\n\t}\r\n\r\n\tstatic divide(a, scalar) {\r\n\t\tscalar = 1 / scalar;\r\n\t\treturn Vector2.multiply(a, scalar);\r\n\t}\r\n\r\n\tstatic dot(a, b) {\r\n\t\treturn a.x * b.x + a.y * b.y;\r\n\t}\r\n\r\n\tstatic dist(a, b) {\r\n\t\tvar vec1 = a.x - b.x;\r\n\t\tvar vec2 = a.y - b.y;\r\n\t\treturn Math.sqrt((vec1 * vec1) + (vec2 * vec2));\r\n\t}\r\n\r\n\tconstructor(x = 0, y = 0) {\r\n\t\tthis.raw = [x,y];\r\n\t}\r\n\r\n\tget x () {\r\n\t\treturn this.raw[0];\r\n\t}\r\n\r\n\tset x (value) {\r\n\t\tthis.raw[0] = value;\r\n\t}\r\n\r\n\tget y () {\r\n\t\treturn this.raw[1];\r\n\t}\r\n\r\n\tset y (value) {\r\n\t\tthis.raw[1] = value;\r\n\t}\r\n\r\n\tget z () {\r\n\t\treturn 0;\r\n\t}\r\n\t\r\n\tget() {\r\n\t\treturn new Vector2(this.x, this.y);\r\n\t}\r\n\r\n\tset(x=0, y=0) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\r\n\tmultiply(scalar) {\r\n\t\tthis.x = this.x * scalar;\r\n\t\tthis.y = this.y * scalar;\r\n\t}\r\n\r\n\tadd(v) {\r\n\t\tthis.x = this.x + v.x;\r\n\t\tthis.y = this.y + v.y;\r\n\t}\r\n\r\n\tsubtract(v) {\r\n\t\tvar n = new Vector2(v.x, v.y);\r\n\t\tn.negate();\r\n\t\tthis.add(n);\r\n\t}\r\n\r\n\tdivide(scalar) {\r\n\t\tscalar = 1 / scalar;\r\n\t\tthis.multiply(scalar);\r\n\t}\r\n\r\n\tnegate() {\r\n\t\tthis.x = -this.x;\r\n\t\tthis.y = -this.y;\r\n\t}\r\n\r\n\tclamp(limit) {\r\n\t\tif (this.x > limit) {\r\n\t\t\tthis.x = limit;\r\n\t\t} else if (this.x < 0 && this.x < limit) {\r\n\t\t\tthis.x = -limit;\r\n\t\t}\r\n\t\tif (this.y > limit) {\r\n\t\t\tthis.y = limit;\r\n\t\t} else if (this.y < 0 && this.y < limit) {\r\n\t\t\tthis.y = -limit;\r\n\t\t}\r\n\t}\r\n\r\n\tlimit(limit) {\r\n\t\tif (this.magnitude() > limit) {\r\n\t\t\tthis.normalize();\r\n\t\t\tthis.multiply(limit);\r\n\t\t}\r\n\t}\r\n\r\n\trotate(degrees, pivotVector = new Vector2(0, 0), stabilize = false) {\r\n\t\tvar mag = this.magnitude();\r\n\t\tvar rads = Convert.degreesToRadians(degrees);\r\n\t\tvar cosineAngle = Math.cos(rads);\r\n\t\tvar sineAngle = Math.sin(rads);\r\n\t\tthis.x = (cosineAngle * (this.x - pivotVector.x)) + (sineAngle * (this.y - pivotVector.y)) + pivotVector.x;\r\n\t\tthis.y = (cosineAngle * (this.y - pivotVector.y)) - (sineAngle * (this.x - pivotVector.x)) + pivotVector.y;\r\n\t\tif (stabilize) {\r\n\t\t\tthis.normalize();\r\n\t\t\tthis.multiply(mag);\r\n\t\t}\r\n\t}\r\n\r\n\tmagnitude() {\r\n\t\treturn Math.sqrt(Vector2.dot(this, this));\r\n\t}\r\n\r\n\tnormalize() {\r\n\t\tvar m = this.magnitude();\r\n\t\tif (m > 0) {\r\n\t\t\tthis.divide(m);\r\n\t\t}\r\n\t}\r\n\r\n}\n\nclass Vector3 {\r\n\r\n    /**\r\n     * Resets the supplied Vector to 0.\r\n     * @param v {Vector3}\r\n     * @static\r\n     */\r\n    static reset(v) {\r\n        v.set(0, 0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * angleBetween() gets the angle between two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @returns {number}\r\n     * @static\r\n     */\r\n    static angleBetween(a, b) {\r\n        var mag = a.magnitude() * b.magnitude();\r\n        var dot = Vector3.dot(a, b);\r\n        return Math.acos(dot / mag);\r\n    }\r\n\r\n    /**\r\n     * Linear interpolation between two vector locations\r\n     * @param a {Vector3} Starting point\r\n     * @param b {Vector3} Ending point\r\n     * @param t {number} The ratio between the two points 0: Start. 1: End.\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     * @static\r\n     */\r\n    static lerp(a, b, t, v = new Vector3()) {\r\n        v.set(\r\n            a.raw[0] + t * (b.raw[0] - a.raw[0]),\r\n            a.raw[1] + t * (b.raw[1] - a.raw[1]),\r\n            a.raw[2] + t * (b.raw[2] - a.raw[2])\r\n        );\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Normalize a Vector\r\n     * @param vector {Vector3}\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     * @static\r\n     */\r\n    static normalize(vector, v = new Vector3()) {\r\n        var vec = vector.get(v);\r\n        vec.normalize();\r\n        return vec;\r\n    }\r\n\r\n    /**\r\n     * Get the Magnitude of a vector\r\n     * @param vector {Vector3}\r\n     * @returns {number}\r\n     * @static\r\n     */\r\n    static magnitude(vector) {\r\n        return Math.sqrt(Vector3.dot(vector, vector));\r\n    }\r\n\r\n    /**\r\n     * Add two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     * @static\r\n     */\r\n    static add(a, b, v = new Vector3()) {\r\n        v.set(a.raw[0] + b.raw[0], a.raw[1] + b.raw[1], a.raw[2] + b.raw[2]);\r\n        return v;\r\n    }\r\n\r\n    static subtract(a, b, v = new Vector3()) {\r\n        v.set(a.raw[0] - b.raw[0], a.raw[1] - b.raw[1], a.raw[2] - b.raw[2]);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Subtract two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     * @static\r\n     */\r\n    static multiply(a, scalar, v = new Vector3()) {\r\n        v.set(a.raw[0] * scalar, a.raw[1] * scalar, a.raw[2] * scalar);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Multiply two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     * @static\r\n     */\r\n    static divide(a, scalar, v = new Vector3()) {\r\n        scalar = 1 / scalar;\r\n        v.set(a.raw[0] * scalar, a.raw[1] * scalar, a.raw[2] * scalar);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Gets the dot product of two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @returns {number}\r\n     * @static\r\n     */\r\n    static dot(a, b) {\r\n        return a.raw[0] * b.raw[0] + a.raw[1] * b.raw[1] + a.raw[2] * b.raw[2];\r\n    }\r\n\r\n    /**\r\n     * Get the cross product of two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     */\r\n    static cross(a, b, v = new Vector3()) {\r\n        v.set(\r\n            a.raw[1] * b.raw[2] - b.raw[1] * a.raw[2],\r\n            a.raw[2] * b.raw[0] - b.raw[2] * a.raw[0],\r\n            a.raw[0] * b.raw[1] - b.raw[0] * a.raw[1]);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Get the distance between two vectors\r\n     * @param a {Vector3}\r\n     * @param b {Vector3}\r\n     * @returns {number}\r\n     */\r\n    static dist(a, b) {\r\n        var vec1 = a.raw[0] - b.raw[0];\r\n        var vec2 = a.raw[1] - b.raw[1];\r\n        var vec3 = a.raw[2] - b.raw[2];\r\n        return Math.sqrt((vec1 * vec1) + (vec2 * vec2) + (vec3 * vec3));\r\n    }\r\n\r\n    /**\r\n     * Creates a new Vector\r\n     * @param x {number}\r\n     * @param y {number}\r\n     * @param z {number}\r\n     * @param w {number}\r\n     * @constructor\r\n     */\r\n    constructor(x = 0, y = 0, z = 0, w = 0) {\r\n        this.raw = new Float32Array(4);\r\n        this.raw[0] = x;\r\n        this.raw[1] = y;\r\n        this.raw[2] = z;\r\n        this.raw[3] = w;\r\n    }\r\n\r\n    get x() {\r\n        return this.raw[0];\r\n    }\r\n\r\n    set x(value) {\r\n        this.raw[0] = value;\r\n    }\r\n\r\n    get y() {\r\n        return this.raw[1];\r\n    }\r\n\r\n    set y(value) {\r\n        this.raw[1] = value;\r\n    }\r\n\r\n    get z() {\r\n        return this.raw[2];\r\n    }\r\n\r\n    set z(value) {\r\n        this.raw[2] = value;\r\n    }\r\n\r\n    get w() {\r\n        return this.raw[3];\r\n    }\r\n\r\n    set w(value) {\r\n        this.raw[3] = value;\r\n    }\r\n\r\n    /**\r\n     * Copy this vector\r\n     * @param v {Vector3} [v= new Vector()] an optional reference instead of allocating a new vector\r\n     * @returns {Vector3}\r\n     */\r\n    get(v = new Vector3()) {\r\n        v.set(this.raw[0], this.raw[1], this.raw[2], this.raw[3]);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Sets the vector to the values passed in\r\n     * @param x {number}\r\n     * @param y {number}\r\n     * @param z {number}\r\n     * @param w {number}\r\n     */\r\n    set(x = 0, y = 0, z = 0, w = 0) {\r\n        this.raw[0] = x;\r\n        this.raw[1] = y;\r\n        this.raw[2] = z;\r\n        this.raw[3] = w;\r\n    }\r\n\r\n    /**\r\n     * Multiplies this vector by a scalar\r\n     * @param scalar {number}\r\n     */\r\n    multiply(scalar) {\r\n        Vector3.multiply(this, scalar, this);\r\n    }\r\n\r\n    /**\r\n     * Adds the vector passed in to this vector\r\n     * @param v {Vector3}\r\n     */\r\n    add(v) {\r\n        Vector3.add(this, v, this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the vector passed in from this vector\r\n     * @param v {Vector3}\r\n     */\r\n    subtract(v) {\r\n        Vector3.subtract(this, v, this);\r\n    }\r\n\r\n    /**\r\n     * Divides this vector by the scalar\r\n     * @param scalar {Vector3}\r\n     */\r\n    divide(scalar) {\r\n        Vector3.divide(this, scalar, this);\r\n    }\r\n\r\n    /**\r\n     * Inverts this vector\r\n     */\r\n    negate() {\r\n        this.raw[0] = -this.raw[0];\r\n        this.raw[1] = -this.raw[1];\r\n        this.raw[2] = -this.raw[2];\r\n    }\r\n\r\n    /**\r\n     * Clamps the vector components to the limit value\r\n     * @param limit {number}\r\n     */\r\n    clamp(limit) {\r\n        if (this.raw[0] > limit) {\r\n            this.raw[0] = limit;\r\n        } else if (this.raw[0] < 0 && this.raw[0] < limit) {\r\n            this.raw[0] = -limit;\r\n        }\r\n        if (this.raw[1] > limit) {\r\n            this.raw[1] = limit;\r\n        } else if (this.raw[1] < 0 && this.raw[1] < limit) {\r\n            this.raw[1] = -limit;\r\n        }\r\n        if (this.raw[2] > limit) {\r\n            this.raw[2] = limit;\r\n        } else if (this.raw[2] < 0 && this.raw[2] < limit) {\r\n            this.raw[2] = -limit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * limits the vector magnitude to the limit value\r\n     * @param limit {number} the maximum magnitude\r\n     */\r\n    limit(limit) {\r\n        if (this.magnitude() > limit) {\r\n            this.normalize();\r\n            this.multiply(limit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rotate this vector\r\n     * @param degrees {number} degrees to rotate the vector by\r\n     * @param pivotVector {Vector3} [pivotVector= new Vector3()] The point that you want to rotate around (default 0,0)\r\n     * @param stabilize {boolean} [stabilize = false] stabilize the rotation of the vector by maintaining it's magnitude\r\n     */\r\n    rotate(degrees, pivotVector = new Vector3(), stabilize = false) {\r\n        var mag = this.magnitude();\r\n        var rads = Convert.DegreesToRadians(degrees);\r\n        var cosineAngle = Math.cos(rads);\r\n        var sineAngle = Math.sin(rads);\r\n        this.raw[0] = (cosineAngle * (this.raw[0] - pivotVector.x)) + (sineAngle * (this.raw[1] - pivotVector.y)) + pivotVector.x;\r\n        this.raw[1] = (cosineAngle * (this.raw[1] - pivotVector.y)) - (sineAngle * (this.raw[0] - pivotVector.x)) + pivotVector.y;\r\n        if (stabilize) {\r\n            this.normalize();\r\n            this.multiply(mag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The magnitude of this vector\r\n     * @returns {number}\r\n     */\r\n    magnitude() {\r\n        return Math.sqrt(Vector3.dot(this, this));\r\n    }\r\n\r\n    /**\r\n     * Normalize this vector\r\n     */\r\n    normalize() {\r\n        var m = this.magnitude();\r\n        if (m > 0) {\r\n            this.divide(m);\r\n        }\r\n    }\r\n\r\n}\n\nclass Matrix3 {\r\n\r\n\tconstructor (array = [1,0,0,0,1,0,0,0,1]) {\r\n\t\tthis.raw = new Float32Array(array);\r\n\t}\r\n\r\n\tsetMatrix (array) {\r\n\t\tthis.raw = array;\r\n\t}\r\n\r\n\tstatic dot (a,b) {\r\n\t\tvar dots = a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n\t\tconsole.log(dots);\r\n\t\treturn dots;\r\n\t}\r\n\r\n\tstatic multiply(a,b) {\r\n\t\tvar matrix = new Float32Array(9);\r\n\t\tmatrix[0] = Matrix3.dot(a.column1, b.row1);\r\n\t\tmatrix[1] = Matrix3.dot(a.column2, b.row1);\r\n\t\tmatrix[2] = Matrix3.dot(a.column3, b.row1);\r\n\t\tmatrix[3] = Matrix3.dot(a.column1, b.row2);\r\n\t\tmatrix[4] = Matrix3.dot(a.column2, b.row2);\r\n\t\tmatrix[5] = Matrix3.dot(a.column3, b.row2);\r\n\t\tmatrix[6] = Matrix3.dot(a.column1, b.row3);\r\n\t\tmatrix[7] = Matrix3.dot(a.column2, b.row3);\r\n\t\tmatrix[8] = Matrix3.dot(a.column3, b.row3);\r\n\t\tvar newMatrix = new Matrix3();\r\n\t\tnewMatrix.setMatrix(matrix);\r\n\t\treturn newMatrix;\r\n\t}\r\n\r\n\tmultiply(matrix) {\r\n\t\tvar newMatrix = Matrix3.multiply(this, matrix);\r\n\t\tthis.raw = newMatrix.raw;\r\n\t}\r\n\r\n\tget column1 () {\r\n\t\treturn [this.raw[0], this.raw[3], this.raw[6]];\r\n\t}\r\n\tget column2 () {\r\n\t\treturn [this.raw[1], this.raw[4], this.raw[7]];\r\n\t}\r\n\tget column3 () {\r\n\t\treturn [this.raw[2], this.raw[5], this.raw[8]];\r\n\t}\r\n\tget row1 () {\r\n\t\treturn [this.raw[0], this.raw[1], this.raw[2]];\r\n\t}\r\n\tget row2 () {\r\n\t\treturn [this.raw[3], this.raw[4], this.raw[5]];\r\n\t}\r\n\tget row3 () {\r\n\t\treturn [this.raw[6], this.raw[7], this.raw[8]];\r\n\t}\r\n\tset column1 (array) {\r\n\t\tthis.raw[0] = array[0];\r\n\t\tthis.raw[3] = array[1];\r\n\t\tthis.raw[6] = array[2];\r\n\t}\r\n\tset column2 (array) {\r\n\t\tthis.raw[1] = array[0];\r\n\t\tthis.raw[4] = array[1];\r\n\t\tthis.raw[7] = array[2];\r\n\t}\r\n\tset column3 (array) {\r\n\t\tthis.raw[2] = array[0];\r\n\t\tthis.raw[5] = array[1];\r\n\t\tthis.raw[68] = array[2];\r\n\t}\r\n\tset row1 (array) {\r\n\t\tthis.raw[0] = array[0];\r\n\t\tthis.raw[1] = array[1];\r\n\t\tthis.raw[2] = array[2];\r\n\t}\r\n\tset row2 (array) {\r\n\t\tthis.raw[3] = array[0];\r\n\t\tthis.raw[4] = array[1];\r\n\t\tthis.raw[5] = array[2];\r\n\t}\r\n\tset row3 (array) {\r\n\t\tthis.raw[6] = array[0];\r\n\t\tthis.raw[7] = array[1];\r\n\t\tthis.raw[8] = array[2];\r\n\t}\r\n\r\n}\n\nclass Matrix4 {\r\n\r\n    constructor (array = Matrix4.identity()) {\r\n        this.setMatrix(array);\r\n    }\r\n\r\n    static identity() {\r\n        return new Float32Array([1,0,0,0,\r\n\t\t\t0,1,0,0,\r\n\t\t\t0,0,1,0,\r\n\t\t\t0,0,0,1])\r\n    }\r\n\r\n    setMatrix (array) {\r\n        this.raw = array;\r\n    }\r\n\r\n    static dot (c1, c2, c3, c4, r1, r2, r3, r4) {\r\n        return c1 * r1 + c2 * r2 + c3 * r3 + c4 * r4;\r\n    }\r\n\r\n    transpose () {\r\n        var row1 = [this.raw[0], this.raw[1], this.raw[2], this.raw[3]];\r\n        var row2 = [this.raw[4], this.raw[5], this.raw[6], this.raw[7]];\r\n        var row3 = [this.raw[8], this.raw[9], this.raw[10], this.raw[11]];\r\n        var row4 = [this.raw[12], this.raw[13], this.raw[14], this.raw[15]];\r\n\r\n        this.raw[0]  = row1[0];\r\n        this.raw[4]  = row1[1];\r\n        this.raw[8]  = row1[2];\r\n        this.raw[12] = row1[3];\r\n\r\n        this.raw[1]  = row2[0];\r\n        this.raw[5]  = row2[1];\r\n        this.raw[9]  = row2[2];\r\n        this.raw[13] = row2[3];\r\n\r\n        this.raw[2]  = row3[0];\r\n        this.raw[6]  = row3[1];\r\n        this.raw[10] = row3[2];\r\n        this.raw[14] = row3[3];\r\n\r\n        this.raw[3]  = row4[0];\r\n        this.raw[7]  = row4[1];\r\n        this.raw[11] = row4[2];\r\n        this.raw[15] = row4[3];\r\n\r\n    }\r\n    \r\n    static multiply(a,b, outputMatrix = new Matrix4()) {\r\n        let matrix = new Float32Array(16);\r\n        //let matrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\r\n        matrix[0] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\r\n        matrix[1] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\r\n        matrix[2] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\r\n        matrix[3] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[0], b.raw[1], b.raw[2], b.raw[3]);\r\n\r\n        matrix[4] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\r\n        matrix[5] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\r\n        matrix[6] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\r\n        matrix[7] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[4], b.raw[5], b.raw[6], b.raw[7]);\r\n\r\n        matrix[8] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\r\n        matrix[9] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\r\n        matrix[10] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\r\n        matrix[11] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[8], b.raw[9], b.raw[10], b.raw[11]);\r\n\r\n        matrix[12] = Matrix4.dot(a.raw[0], a.raw[4], a.raw[8], a.raw[12], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\r\n        matrix[13] = Matrix4.dot(a.raw[1], a.raw[5], a.raw[9], a.raw[13], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\r\n        matrix[14] = Matrix4.dot(a.raw[2], a.raw[6], a.raw[10], a.raw[14], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\r\n        matrix[15] = Matrix4.dot(a.raw[3], a.raw[7], a.raw[11], a.raw[15], b.raw[12], b.raw[13], b.raw[14], b.raw[15]);\r\n        //console.log(outputMatrix);\r\n        outputMatrix.setMatrix(matrix);\r\n        return outputMatrix;\r\n    }\r\n\r\n    multiply(matrix) {\r\n        Matrix4.multiply(this, matrix, this);\r\n    }\r\n\r\n    static multiplyVector (v3, matrix, v = new Vector3()) {\r\n\t\tv.set(  matrix[0]*v3.raw[0],    matrix[1]*v3.raw[1],    matrix[2]*v3.raw[2],    matrix[3]*v3.raw[3],\r\n                matrix[4]*v3.raw[0],    matrix[5]*v3.raw[1],    matrix[6]*v3.raw[2],    matrix[7]*v3.raw[3],\r\n                matrix[8]*v3.raw[0],    matrix[9]*v3.raw[1],    matrix[10]*v3.raw[2],   matrix[11]*v3.raw[3],\r\n                matrix[12]*v3.raw[0],   matrix[13]*v3.raw[1],   matrix[14]*v3.raw[2],   matrix[15]*v3.raw[3]);\r\n\t\treturn v;\r\n    }\r\n\r\n    static translate(v3) {\r\n\r\n\r\n    }\r\n\r\n    static scale(v3) {}\r\n\r\n}\n\nlet hexString = \"0123456789abcdef\";\r\n\r\nclass Generate {\r\n\r\n    static RandomHexString(length) {\r\n        let bytes = \"\";\r\n        for(let i = 0; i<length; i++) {\r\n            bytes += hexString.substr(Math.floor(Math.random()*hexString.length),1);\r\n        }\r\n        return bytes;\r\n    }\r\n    \r\n    static UUID () {\r\n        return `${Generate.RandomHexString(8)}-${Generate.RandomHexString(4)}-${Generate.RandomHexString(4)}-${Generate.RandomHexString(4)}-${Generate.RandomHexString(12)}`\r\n    }\r\n    \r\n}\n\nlet pools = new Object();\r\nlet objectPool = new Object();\r\nlet usagePool = new Object();\r\nlet clean = new Object();\r\n\r\nclass Pool {\r\n\r\n    static allocate(object, objectKey, number, cleaner = function(item){return item}) {\r\n\r\n        if (object.hasOwnProperty(\"prototype\")) {\r\n            pools[objectKey] = {\r\n                object: object,\r\n                objectKey: objectKey,\r\n                amount: number,\r\n                cleaner: cleaner\r\n            };\r\n            clean[objectKey] = cleaner;\r\n            usagePool[objectKey] = [];\r\n            objectPool[objectKey] = [];\r\n            for (var i = 0; i < number; i++) {\r\n                var instance = new object();\r\n                    instance.v_pool_index = i;\r\n                    instance.v_pool_key = objectKey;\r\n                usagePool[objectKey][i] = false;\r\n                objectPool[objectKey][i] = instance;\r\n            }\r\n            return objectPool[objectKey];\r\n        } else {\r\n            throw new Error(\"Object must have a constructor\");\r\n        }\r\n    }\r\n\r\n    static deallocate(objectKey, force = false) {\r\n        if(Pool.referencesInPool(objectKey) == 0 || force == true) {\r\n            delete clean[objectKey];\r\n            delete usagePool[objectKey];\r\n            delete objectPool[objectKey];\r\n            delete pools[objectKey];\r\n        } else {\r\n            console.warn(\"You still have objects in this pool checked out. Return them and call deallocate. Or use deallocate(key, true) to force deallocation.\");\r\n        }\r\n    }\r\n\r\n    static referencesInPool(objectKey){\r\n        return pools[objectKey].amount - Pool.poolsize(objectKey);\r\n    }\r\n\r\n    static poolsize(objectKey) {\r\n        return objectPool[objectKey].filter(Pool.notInUse).length;\r\n    }\r\n\r\n    static inUse(object) {\r\n        return usagePool[object.v_pool_key][object.v_pool_index];\r\n    }\r\n\r\n    static notInUse(object) {\r\n        return !usagePool[object.v_pool_key][object.v_pool_index];\r\n    }\r\n\r\n    static returnAll(objectKey) {\r\n        var objects = objectPool[objectKey].filter(Pool.inUse);\r\n        for(var i = 0; i < objects.length; i++) {\r\n            Pool.returnObject(objects[i]);\r\n        }\r\n    }\r\n\r\n    static getObject(objectKey) {\r\n        var i = usagePool[objectKey].indexOf(false);\r\n                usagePool[objectKey][i] = true;\r\n        if(i > -1) {\r\n            return objectPool[objectKey][i];\r\n        } else {\r\n            throw new Error(\"Out of objects\");\r\n        }\r\n    }\r\n\r\n    static returnObject(obj) {\r\n        clean[obj.v_pool_key](obj);\r\n        usagePool[obj.v_pool_key][obj.v_pool_index] = false;\r\n    }\r\n    static returnObjects(objs) {\r\n        for(var i = 0; i<objs.length; i++) {\r\n            Pool.returnObject(objs[i]);\r\n        }\r\n    }\r\n    static get Pools () {\r\n        return pools;\r\n    }\r\n\r\n}\n\nlet listeners = {};\r\n\r\nclass EventLite {\r\n    static on (event, handler) {\r\n        if (listeners[event] === undefined) {\r\n            listeners[event] = [handler];\r\n        } else {\r\n            listeners[event].push(handler);\r\n        }\r\n        return handler;\r\n    }\r\n    static off (event, handler) {\r\n        if (listeners[event]) {\r\n            for (let i = listeners[event].length - 1; i >= 0; i--) {\r\n                if (listeners[event].length === 1) {\r\n                    delete listeners[event];\r\n                } else {\r\n                    listeners[event].splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static trigger (event, ...data) {\r\n        if (listeners[event]) {\r\n            for (let i = listeners[event].length - 1; i >= 0; i--) {\r\n                if(listeners[event] !== undefined) {\r\n                    if (typeof listeners[event][i] === \"function\" && listeners[event][i] ) {\r\n                        listeners[event][i](data);\r\n                    } else {\r\n                        throw \"Event handler is not a function.\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static unbindAll () {\r\n        for (const event in listeners) {\r\n            delete listeners[event];\r\n        }\r\n        return true;\r\n    };\r\n}\n\nvar resizeId;\r\nvar resizeEvent;\r\nclass Screen {\r\n    static get dimensions() {\r\n        return Screen._dimensions;\r\n    }\r\n    static set dimensions(value) {\r\n        if(Screen._dimensions != value) {\r\n            Screen._dimensions = value;\r\n        }\r\n    }\r\n    static get orientation() {\r\n        return Screen._orientation;\r\n    }\r\n    static set orientation(value) {\r\n        if(Screen._orientation != value) {\r\n            Screen._orientation = value;\r\n        }\r\n    }\r\n    static get center() {\r\n        return Screen._center;\r\n    }\r\n    static set center(value) {\r\n        if(Screen._center != value) {\r\n            Screen._center = value;\r\n        }\r\n    }\r\n    static get resizeDelay() {\r\n        return Screen._resizeDelay;\r\n    }\r\n    static set resizeDelay(value) {\r\n        if(Screen._resizeDelay != value) {\r\n            Screen._resizeDelay = value;\r\n        }\r\n    }\r\n    static get anchors() {\r\n        return Screen._anchors;\r\n    }\r\n    static set anchors(value) {\r\n        if(Screen._anchors != value) {\r\n            Screen._anchors = value;\r\n        }\r\n    }\r\n    static get anchorPositions() {\r\n        return Screen._anchorPositions;\r\n    }\r\n    static set anchorPositions(value) {\r\n        if(Screen._anchorPositions != value) {\r\n            Screen._anchorPositions = value;\r\n        }\r\n    }\r\n    static get width () {\r\n        return Screen._dimensions.x;\r\n    }\r\n    static get height () {\r\n        return Screen._dimensions.y;\r\n    }\r\n    static resize(e) {\r\n        clearTimeout(resizeId);\r\n        resizeEvent = e;\r\n        resizeId = setTimeout(Screen.recalculate, Screen.resizeDelay);\r\n    }\r\n\r\n    static recalculate() {\r\n        Screen.dimensions.set(window.innerWidth, window.innerHeight);\r\n        if(Screen.dimensions.x > Screen.dimensions.y) {\r\n            Screen.orientation = \"landscape\";\r\n        } else {\r\n            Screen.orientation = \"portrait\";\r\n        }\r\n        for(var anchor in Screen.anchors) {\r\n            if(Screen.anchors.hasOwnProperty(anchor)) {\r\n                Screen.anchorPositions[anchor].set(Screen.anchors[anchor].x * Screen.dimensions.x, Screen.anchors[anchor].y * Screen.dimensions.y);\r\n            }\r\n        }\r\n\r\n        EventLite.trigger(\"resize\", resizeEvent);\r\n    }\r\n\r\n    static getAnchor(name) {\r\n        return Screen.anchorPositions[name].get();\r\n    }\r\n\r\n    static setAnchor(name, ratioX, ratioY) {\r\n\r\n        if(Screen.anchors[name] == undefined) {\r\n            Screen.anchors[name] = new Vector3(ratioX, ratioY);\r\n            Screen.anchorPositions[name] = new Vector3(Screen.anchors[name].x * Screen.dimensions.x, Screen.anchors[name].y * Screen.dimensions.y);\r\n        } else {\r\n            Screen.anchors[name].set(ratioX, ratioY);\r\n            Screen.anchorPositions[name].set(Screen.anchors[name].x * Screen.dimensions.x, Screen.anchors[name].y * Screen.dimensions.y);\r\n        }\r\n\r\n    }\r\n    static removeAnchor (name) {\r\n        delete Screen.anchors[name];\r\n        delete Screen.anchorPositions[name];\r\n    }\r\n    static init() {\r\n        Screen.resizeDelay = 100;\r\n        Screen.anchors = {};\r\n        Screen.anchorPositions = {};\r\n        Screen.dimensions = new Vector3(window.innerWidth, window.innerHeight);\r\n        Screen.setAnchor(\"center\", 0.5, 0.5);\r\n        if(Screen.dimensions.x > Screen.dimensions.y) {\r\n            Screen.orientation = \"landscape\";\r\n        } else {\r\n            Screen.orientation = \"portrait\";\r\n        }\r\n    }\r\n\r\n}\r\nScreen.init();\n\n/**\r\n * Behaviors are applied to Actors by passing actors, target actors, and parameters into them.\r\n * @class Behaviors\r\n */\r\nconst key = Generate.UUID();\r\nclass Behavior {\r\n    /**\r\n     * init is a static method that is used to initialize the object pool\r\n     */\r\n    static init() {\r\n        Pool.allocate(Vector3, key, 10, Vector3.reset);\r\n    }\r\n\r\n    /**\r\n     * seek() finds the distance between the actor and the targetLcation and applys a force to move the actor toward that target.\r\n     * @param actor {Actor}\r\n     * @param targetPosition {Vector3}\r\n     * @param scaleForce {?number}\r\n     */\r\n    static seek(actor, targetPosition, scaleForce = 1) {\r\n        var desired = Pool.getObject(key);\r\n        var steer = Pool.getObject(key);\r\n\r\n        Vector3.subtract(targetPosition, actor.location, desired);\r\n        desired.normalize();\r\n        desired.multiply(actor.maxSpeed);\r\n        Vector3.subtract(desired, actor.velocity, steer);\r\n\r\n        steer.limit(actor.maxForce);\r\n        steer.multiply(scaleForce);\r\n        actor.addForce(steer);\r\n\r\n        Pool.returnObject(desired);\r\n        Pool.returnObject(steer);\r\n    }\r\n\r\n    /**\r\n     * arrive() works similarly to seek, but with the magnitude of the seek mapped to a power that is inversely proportionate to the magnitude of the distance between the actor and the target.\r\n     * @param actor {Actor}\r\n     * @param target {Vector3}\r\n     * @param power {?number}\r\n     * @param scaleForce {?number}\r\n     */\r\n    static arrive(actor, target, power = 50, scaleForce = 1) {\r\n        var desired = Pool.getObject(key);\r\n        var steer = Pool.getObject(key);\r\n        Vector3.subtract(target, actor.location, desired);\r\n        var mappedPower = Convert.MapRange(desired.magnitude(), 0, power, 0, actor.maxSpeed);\r\n        desired.normalize();\r\n        desired.multiply(mappedPower);\r\n        Vector3.subtract(desired, actor.velocity, steer);\r\n        steer.limit(actor.maxForce);\r\n        steer.multiply(scaleForce);\r\n        actor.addForce(steer);\r\n        Pool.returnObject(desired);\r\n        Pool.returnObject(steer);\r\n    }\r\n\r\n    /**\r\n     * avoidAll() takes an array of obstacle actors and for each obstacle, the Actor will have the average escape vector of all the obstacles near it applied to it.\r\n     * @param actor {Actor}\r\n     * @param obstacles {Array.<Actor>}\r\n     * @param avoidRadius {?number}\r\n     * @param scaleForce {?number}\r\n     */\r\n    static avoidAll(actor, obstacles, avoidRadius = 80, scaleForce = 1) {\r\n        var difference = Pool.getObject(key);\r\n        var steer = Pool.getObject(key);\r\n        var total = Pool.getObject(key);\r\n        var count = 0;\r\n        for (var o = 0; o < obstacles.length; o++) {\r\n            var obstacle = obstacles[o];\r\n            var distance = Vector3.dist(actor.location, obstacle.location);\r\n            if ((distance > 0) && (distance < avoidRadius) && actor.id != obstacle.id) {\r\n                Vector3.subtract(actor.location, obstacle.location, difference);\r\n                difference.normalize();\r\n                difference.divide(distance);\r\n                total.add(difference);\r\n                count++;\r\n            }\r\n        }\r\n        if (count > 0) {\r\n            total.divide(count);\r\n            total.normalize();\r\n            total.multiply(actor.maxSpeed);\r\n            Vector3.subtract(total, actor.velocity, steer);\r\n            steer.limit(actor.maxForce);\r\n            steer.multiply(scaleForce);\r\n            actor.addForce(steer);\r\n        }\r\n        Pool.returnObject(difference);\r\n        Pool.returnObject(steer);\r\n        Pool.returnObject(total);\r\n    }\r\n\r\n    /**\r\n     * Uses a single obstacle in the avoidAll function\r\n     * @param actor\r\n     * @param target\r\n     * @param avoidRadius\r\n     */\r\n    static avoid(actor, target, avoidRadius) {\r\n        this.avoidAll(actor, [target], avoidRadius);\r\n    }\r\n\r\n    /**\r\n     * constrain() will lock your actor to the provided area. Velocity will be inverted with no friction when an Actor hits the wall.\r\n     * @param actor {Actor}\r\n     * @param minWidth {number} Left\r\n     * @param minHeight {number} Uo\r\n     * @param maxWidth {number} Right\r\n     * @param maxHeight {number} Bottom\r\n     * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n     */\r\n    static constrain(actor, minWidth = 0, minHeight = 0, maxWidth = Screen.width, maxHeight = Screen.height, margin = 0) {\r\n        minWidth -= margin;\r\n        maxWidth += margin;\r\n        minHeight -= margin;\r\n        maxHeight += margin;\r\n\r\n        if (actor.location.x < minWidth) {\r\n            actor.velocity.x *= -1;\r\n            actor.location.x = minWidth;\r\n        }\r\n        if (actor.location.y < minHeight) {\r\n            actor.velocity.y *= -1;\r\n            actor.location.y = minHeight;\r\n        }\r\n        if (actor.location.x > maxWidth) {\r\n\r\n            actor.velocity.x *= -1;\r\n            actor.location.x = maxWidth;\r\n        }\r\n        if (actor.location.y > maxHeight) {\r\n            actor.velocity.y *= -1;\r\n            actor.location.y = maxHeight;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * wrap() will teleport your object to the opposite side of the screen where it left\r\n     * @param actor {Actor}\r\n     * @param minWidth {number} Left\r\n     * @param minHeight {number} Uo\r\n     * @param maxWidth {number} Right\r\n     * @param maxHeight {number} Bottom\r\n     * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n     */\r\n    static wrap(actor, minWidth = 0, minHeight = 0, maxWidth = Screen.width, maxHeight = Screen.height, margin = 0) {\r\n        minWidth -= margin;\r\n        maxWidth += margin;\r\n        minHeight -= margin;\r\n        maxHeight += margin;\r\n\r\n        if (actor.location.x < minWidth) {\r\n            actor.location.x = maxWidth;\r\n        }\r\n        if (actor.location.y < minHeight) {\r\n            actor.location.y = maxHeight;\r\n        }\r\n        if (actor.location.x > maxWidth) {\r\n            actor.location.x = minWidth;\r\n        }\r\n        if (actor.location.y > maxHeight) {\r\n            actor.location.y = minHeight;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * disableOutside will set your Actor.active parameter to \"false\" when it leaves the defined area\r\n     * @param actor {Actor}\r\n     * @param minWidth {number} Left\r\n     * @param minHeight {number} Uo\r\n     * @param maxWidth {number} Right\r\n     * @param maxHeight {number} Bottom\r\n     * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n     */\r\n    static disableOutside(actor, minWidth, minHeight, maxWidth, maxHeight, margin = 0) {\r\n        minWidth -= margin;\r\n        maxWidth += margin;\r\n        minHeight -= margin;\r\n        maxHeight += margin;\r\n\r\n        if (actor.location.x < minWidth || actor.location.y < minHeight || actor.location.x > maxWidth || actor.location.y > maxHeight) {\r\n            actor.active = false;\r\n            actor.visible = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * destroyOutside will set Actor.dead to true if it leaves the defined area;\r\n     * @param actor {Actor}\r\n     * @param minWidth {number} Left\r\n     * @param minHeight {number} Uo\r\n     * @param maxWidth {number} Right\r\n     * @param maxHeight {number} Bottom\r\n     * @param margin {number} the amount of offset you want for these values. The margins work by subtracting from minimums and adding to maximums.\r\n     */\r\n    static destroyOutside(actor, minWidth, minHeight, maxWidth, maxHeight, margin = 0) {\r\n        minWidth -= margin;\r\n        maxWidth += margin;\r\n        minHeight -= margin;\r\n        maxHeight += margin;\r\n        if (actor.location.x < minWidth || actor.location.y < minHeight || actor.location.x > maxWidth || actor.location.y > maxHeight) {\r\n            actor.dead = true;\r\n        }\r\n    }\r\n}\r\nBehavior.init();\n\n/**\r\n *    The Actor class is used by Behaviors to apply behaviors to.\r\n *  @Class Actor\r\n */\r\n\r\nclass Actor {\r\n    /**\r\n     * @constructor\r\n     * @param className {string}\r\n     * @param location {Vector3)\r\n     */\r\n    constructor(className = \"Actor\", location = new Vector3(0, 0, 0)) {\r\n        this.type = className;\r\n        this.active = true;\r\n        this.visible = true;\r\n        this.dead = false;\r\n        this.id = Generate.UUID();\r\n        this.location = location;\r\n        this.velocity = new Vector3(0, 0, 0);\r\n        this.acceleration = new Vector3(0, 0, 0);\r\n        this.angle = 0;\r\n        this.maxSpeed = 15;\r\n        this.maxForce = 1;\r\n    }\r\n\r\n    /**\r\n     * addForce() will add the vector you pass in to the acceleration\r\n     * @param vector {Vector3}\r\n     */\r\n    addForce(vector) {\r\n        this.acceleration.add(vector);\r\n    }\r\n\r\n    /**\r\n     * update() will check to see if this actor is active, then call move(), then add the acceleration to the velocity, the velocity to the location, then reset the acceleration.\r\n     */\r\n    update() {\r\n        if (this.active) {\r\n            this.move();\r\n            this.velocity.add(this.acceleration);\r\n            this.location.add(this.velocity);\r\n            this.acceleration.set(0, 0, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * move() is unused in the base class and is designed to be overridden. Anything in the move function will be applied before acceleration is added to velocity. See DOMActor for an example.\r\n     */\r\n    move() {\r\n\r\n    }\r\n\r\n    /**\r\n     * render() checks if the actor is visible then calls the draw() function. See DOMActor for an example.\r\n     */\r\n    render() {\r\n        if (this.visible) {\r\n            this.draw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * draw() is empty in this class but can be extended to render itself in any rendering environment of your choice. See DOMActor for an example.\r\n     */\r\n    draw() {\r\n        // override this function win your drawing code\r\n    }\r\n\r\n    /**\r\n     * destroy() sets the Actor.dead state to true. This is used by the GameLoop class to clean up / remove dead objects.\r\n     */\r\n    destroy() {\r\n        this.dead = true;\r\n    }\r\n}\n\n/**\r\n * DOMActor is an extension of the Actor class specifically for working with DOM elements.\r\n * @class DOMActor\r\n * @extends Actor\r\n */\r\n\r\nclass DOMActor extends Actor {\r\n    /**\r\n     * @param className {string} the CSS class you want to use for this DOMActor\r\n     * @param location {Vector3} The starting location for this Actor\r\n     * @constructor\r\n     */\r\n    constructor(className, location) {\r\n        super(className, location);\r\n        this.element = document.createElement(\"div\");\r\n        this.element.classList.add(\"actor\");\r\n        this.element.classList.add(className);\r\n        this.parentElement = null;\r\n    }\r\n\r\n    /**\r\n     * addToParentElement() will add DOMActor.element to the parentElement\r\n     * @param parentElement {HTMLElement}\r\n     */\r\n    addToParentElement(parentElement) {\r\n        this.parentElement = parentElement;\r\n        this.parentElement.appendChild(this.element);\r\n    }\r\n\r\n    /**\r\n     * draw() sets this DOMActor.element.style.transform to `translateX(${this.location.x}px) translateY(${this.location.y}px) rotate(${this.angle}deg)`\r\n     */\r\n    draw() {\r\n        this.element.style.transform =\r\n            `translateX(${this.location.x}px) translateY(${this.location.y}px) rotate(${this.angle}deg)`;\r\n    }\r\n\r\n    /**\r\n     * destroy() sets this DOMActor to dead, removes it from the DOM, and nulls its reference to the parentElement\r\n     */\r\n    destroy() {\r\n        this.dead = true;\r\n        this.element.remove();\r\n        this.parentElement = null;\r\n    }\r\n}\n\nclass GameLoop {\r\n\tconstructor() {\r\n\t\tthis.gameObjects = [];\r\n\t\tthis.controller = [];\r\n\t}\r\n\r\n\tsetController(inputController) {\r\n\t\tthis.controller.push(inputController);\r\n\t}\r\n\r\n\tgetType(type) {\r\n\t\tvar matches = [];\r\n\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\r\n\t\t\tif (this.gameObjects[i].type === type) {\r\n\t\t\t\tmatches.push(this.gameObjects[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn matches;\r\n\t}\r\n\r\n\tupdate() {\r\n\t\tthis.removeActors();\r\n\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\r\n\t\t\tthis.gameObjects[i].update();\r\n\t\t}\r\n\t}\r\n\r\n\taddActor(actor) {\r\n\t\tthis.gameObjects.push(actor);\r\n\t}\r\n\r\n\tremoveActors() {\r\n\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\r\n\t\t\tif(this.gameObjects[i].dead) {\r\n\t\t\t\tthis.gameObjects.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trender() {\r\n\t\tfor (var i = 0; i < this.gameObjects.length; i++) {\r\n\t\t\tthis.gameObjects[i].render();\r\n\t\t}\r\n\t}\r\n\r\n\tloop() {\r\n\t\tthis.update();\r\n\t\tthis.render();\r\n\t\twindow.requestAnimationFrame(this.loop.bind(this));\r\n\t}\r\n}\n\nclass InputController {\r\n\tconstructor() {\r\n\t\tthis.keyMap = {};\r\n\t\tthis.mousePos = new Vector3();\r\n\t}\r\n\r\n\tbindEvents() {\r\n\t\tdocument.addEventListener(\"mouseup\", this.setMouseUp.bind(this));\r\n\t\tdocument.addEventListener(\"mousedown\", this.setMouseDown.bind(this));\r\n\t\tdocument.addEventListener(\"mousemove\", this.setMousePos.bind(this));\r\n\t\tdocument.addEventListener(\"keyup\",this.mapKeys.bind(this));\r\n\t\tdocument.addEventListener(\"keydown\",this.mapKeys.bind(this));\r\n\t}\r\n\r\n\tunbindEvents() {\r\n\t\tdocument.removeEventListener(\"mouseup\", this.setMouseUp.bind(this));\r\n\t\tdocument.removeEventListener(\"mousedown\", this.setMouseDown.bind(this));\r\n\t\tdocument.removeEventListener(\"mousemove\", this.setMousePos.bind(this));\r\n\t\tdocument.removeEventListener(\"keyup\",this.mapKeys.bind(this));\r\n\t\tdocument.removeEventListener(\"keydown\",this.mapKeys.bind(this));\r\n\t}\r\n\r\n\tsetMousePos(e) {\r\n\t\tthis.mousePos.set(e.pageX, e.pageY);\r\n\t}\r\n\r\n\tsetMouseUp(e) {\r\n\t\tvar fakeKey = {\r\n\t\t\tkey: \"mouse\" + e.button,\r\n\t\t\ttype: \"keyup\"\r\n\t\t};\r\n\t\tthis.mapKeys(fakeKey);\r\n\t}\r\n\r\n\tsetMouseDown(e) {\r\n\t\tvar fakeKey = {\r\n\t\t\tkey: \"mouse\" + e.button,\r\n\t\t\ttype: \"keydown\"\r\n\t\t};\r\n\t\tthis.mapKeys(fakeKey);\r\n\t}\r\n\r\n\tmapKeys(e) {\r\n\t\te = e || event;\r\n\t\tthis.keyMap[e.key] = e.type == 'keydown';\r\n\t}\r\n\r\n\tkeyUp(key) {\r\n\t\tconsole.log(key);\r\n\t}\r\n\r\n\tkeyDown(key) {\r\n\t\tconsole.log(key);\r\n\t}\r\n\r\n\tsetKeys() {\r\n\t\tfor (var key in this.keyMap) {\r\n\t\t\tif (this.keyMap[key]) {\r\n\t\t\t\tthis.keyDown(key);\r\n\t\t\t} else {\r\n\t\t\t\tthis.keyUp(key);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nexport { Vector2, Vector3, Matrix3, Matrix4, Behavior as Behaviors, Actor, DOMActor, GameLoop, Screen, InputController, EventLite, Pool, Convert, Generate };\n"],"file":"vexr.es6.js"}